#Generate interval-censored time-to-event data for CVD


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, eval=F)
```

```{r}
library(tidyverse)
library(data.table)
library(lubridate)
source("functions.R")
```

##Determining whether dates of DM diagnosis are known or unknown

Load all_ukb_events_tab to find patients with self-reported diagnosis dates
```{r}
all_ukb_events_tab <- readRDS("generated_data/all_ukb_events_tab.RDS")
known_date_selfrep <- all_ukb_events_tab %>% filter(type == "selfrep" & key %in% c('1220', '1222', '1223')) %>% select(f.eid, event_dt)
```

Load data on first dm diagnosis and gp visits
```{r}
dm_firstoccur <- readRDS("generated_data/dm_firstoccur.RDS")
entire_gp_clinical <- fread("generated_data/entire_gp_clinical_30March2021_formatted.txt", select = c('f.eid', 'event_dt'))
```

Determine which patients have gp visits for two years before first dm diagnosis
```{r}
known_date_gp <- entire_gp_clinical %>% mutate(yr = year(event_dt)) 
known_date_gp <- known_date_gp %>% distinct(f.eid, yr)
known_date_gp <- merge(known_date_gp, dm_firstoccur, by='f.eid') %>% filter(year(event_dt)-1==yr | year(event_dt)-2==yr)
known_date_gp <- known_date_gp %>% subset(duplicated(f.eid)) %>% distinct(f.eid, event_dt)
```

Categorize patients according to whether or not dates are known and save the results in dm_date_known.RDS
```{r}
#We see all firstoccur dates are earlier so we keep these and do not use the later, self-reported dates
firstoccur_selfrep <- merge(dm_firstoccur, known_date_selfrep, by='f.eid')

dm_date_known <- dm_firstoccur %>% mutate(known = ifelse(f.eid %in% known_date_selfrep$f.eid | f.eid %in% known_date_gp$f.eid,1,0))
```

Recategorize known dm dates as unknown if the first DR diagnosis was in the same year because it is unlikely that the patient truly had DM for less than a year before being diagnosed with DR
```{r}
#Define margin variable which is the minimum amount of time needed between dm and dr diagnoses to allow that dm is still known
#currently 1 (which translates to 1 year) but may be changed
margin <- 1

dr_firstoccur <-  readRDS("generated_data/dr_firstoccur.RDS")
dr_firstoccur <- dr_firstoccur %>% select('f.eid', 'event_dt')
dm_date_known <- dm_date_known %>% 
  merge(dr_firstoccur, by='f.eid', all.x=T,suffix = c('_dm', '_dr')) %>% 
mutate(new_known = ifelse(known == 0, 0,
ifelse(decimal_date(event_dt_dr) - decimal_date(event_dt_dm) >= margin | is.na(event_dt_dr), known, 0)))
dm_date_known <- dm_date_known %>% select('f.eid', 'event_dt_dm', 'known'='new_known') %>% rename('event_dt'='event_dt_dm')
```

Save the results
```{r}
saveRDS(dm_date_known, "generated_data/dm_date_known.RDS")
```

##Creating interval censored data

Load diagnosis dates for DM with flag indicating whether or not they are known, dates of first occurrence of cvd, and demographic information 
```{r}
dm_date_known <- readRDS("generated_data/dm_date_known.RDS")
cvd_firstoccur <- readRDS("generated_data/cvd_firstoccur_ukb.RDS")
demog <- readRDS("generated_data/demog_selected.RDS")
```

Load exclusion events tables
```{r}
cardio <- readRDS("generated_data/cardio_control_exclusion_events_ukb.RDS")
cerebro <- readRDS("generated_data/cerebro_control_exclusion_events_ukb.RDS")
other_revas <- readRDS("generated_data/other_revas_control_exclusion_events_ukb.RDS")
```

Combine all control exclusion events
```{r}
ctrl_exclusion_events <- list(cardio, cerebro, other_revas) %>% bind_rows()
```

Create list of f.eid's to be excluded
```{r}
ctrl_exclusion_ids_cvd <- ctrl_exclusion_events %>% select('f.eid') %>% unique
```

Define intervals for time-to-event 
```{r}
#Run the phenotype_time_to_event_interval function on the dm dates, the cvd dates, the demographic information, the control inclusion ids, the DOB as the alternative diabetes diagnosis date, without filtering out subjects with lower bounds less than 5 years. 
cvd_interval_result <- phenotype_time_to_event_interval(dm_date_known, cvd_firstoccur, demog, ctrl_exclusion_ids_cvd$f.eid, dm_alternative = demog %>% select(f.eid, DOB) %>% rename('event_dt'='DOB'))
```

Save the resulting intervals
```{r}
saveRDS(cvd_interval_result, "generated_data/cvd_interval.RDS")
```




