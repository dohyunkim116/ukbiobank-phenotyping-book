[["index.html", "Phenotyping time-to-event traits in UK Biobank Preface", " Phenotyping time-to-event traits in UK Biobank Do Hyun Kim, Aubrey Jensen, Hua Zhou, and Jin Zhou 2023-01-15 Preface This book presents steps for phenotyping survival outcomes using data from UK Biobank (UKB) study (Sudlow 2015). The following are the outcomes we phenotyped: Diabetes Myocardial Infarction Unstable Angina Ischemic Stroke Hemorrhagic Stroke Stroke Percutaneous Coronary Intervention (PCI) Composite cardiovascular disease (CVD) Diabetic Eye Disease or Diabetic Retinopathy (DR) Chronic/Diabetic Kidney Disease (CKD/DKD) We will refer UKB assessment center data as “UKB data” and the associated primary care data as “UKB primary care data.” These two sources of data will be prepared separately and then combined to create event tables for various outcomes. These tables will then be used to phenotype survival traits. References "],["1-reformat-raw-data.html", "1 Clean raw UKB assesment center data", " 1 Clean raw UKB assesment center data We first reformat raw UKB assessment center data using the R scripts (ending with .r) in raw_data folder for easier downstream data wrangling. These scripts were first auto-generated using the ukbconv utility, which automatically applies encodings to data fields. We have slightly modified the auto-generated scripts to achieve a faster reading of data by using fread() function from data.table package rather than the default read.table() function. We also changed the default naming of the R objects storing each dataset to something more descriptive which reflects the contents. The ukbconv utility can be obtained from the download section of the UKB showcase website. We used the ukbconv with a flag -i to specify a subset of fields to be included in each dataset. For further details on downloading, decrypting, and converting the format of your main dataset(s), see UK Biobank’s insructions. Load packages. library(tidyverse) library(data.table) Execute the reformatting scripts. source(&quot;raw_data/demog_UKB_MOD.r&quot;) source(&quot;raw_data/assessment_center_UKB.r&quot;) source(&quot;raw_data/first_occurrences_UKB_MOD.r&quot;) source(&quot;raw_data/ICD_UKB_MOD.r&quot;) source(&quot;raw_data/OPCS_procedures_UKB_MOD.r&quot;) source(&quot;raw_data/sampleQC_UKB_MOD.r&quot;) source(&quot;raw_data/labs_UKB_MOD.r&quot;) Save reformatted UKB assessment center data. saveRDS(demog,&quot;generated_data/demog_UKB.RDS&quot;) saveRDS(bd,&quot;generated_data/assessment_center_UKB.RDS&quot;) saveRDS(firstoccurs,&quot;generated_data/first_occur_UKB.RDS&quot;) saveRDS(procs,&quot;generated_data/OPCS_procedures_UKB.RDS&quot;) saveRDS(ICD,&quot;generated_data/ICD_UKB.RDS&quot;) saveRDS(sampleqc,&quot;generated_data/sampleQC_UKB.RDS&quot;) saveRDS(labs,&quot;generated_data/labs_UKB.RDS&quot;) "],["2-curate-demog-table.html", "2 Curate demographic table", " 2 Curate demographic table In this chapter, we curate a demographic table containing following information: the date of birth gender age at UKB study initial assessment age at UKB study repeat assessment date of UKB study initial assessment date of UKB study repeat assessment censored date The censored date is defined as the earliest date among administrative censoring date, date of last contact and date of death. Load packages. library(tidyverse) library(lubridate) Load formatted raw demographic data. demog &lt;- readRDS(&quot;generated_data/demog_UKB.RDS&quot;) Define the date of birth and gender. demog &lt;- demog %&gt;% rename(YOB = f.34.0.0) %&gt;% rename(MOB = f.52.0.0) %&gt;% mutate(DOB = lubridate::make_date(YOB, MOB)) %&gt;% mutate(SEX = as.character(f.31.0.0)) Define UKB study initiation date. demog &lt;- demog %&gt;% rename(date_init = f.53.0.0, date_repeat = f.53.1.0) We will define administrative censoring date (study end date) based on inpatient record origin. These dates are updated periodically. The most recent censoring dates can be found here in the “Showcase censoring date” field of the table under the “Hospital inpatient data” section. The below censoring dates were based on the page accessed on Feb 22 2022: Patient Episode Database for Wales (PEDW): Feb 28 2018 Scottish Morbidity Record (SMR): Jul 31 2021 Hospital Episode Statistics for England (HES): Sep 30 2021 PEDW, SMR and HES are hospital admission keys (fields f.40022.0.0, f.40022.0.1 and f.40022.0.2 in demog) which map to certain administrative censoring dates. Define a dictionary which maps hospital admission keys to administrative censoring dates. censor_dates &lt;- c(PEDW = as.Date(&quot;2018-02-28&quot;), SMR = as.Date(&quot;2021-07-31&quot;), HES = as.Date(&quot;2021-09-30&quot;)) We take the administrative censoring date as the minimum of these three mapped dates for each subject. demog &lt;- demog %&gt;% mutate(date_admin_censored = as.Date(pmin(censor_dates[f.40022.0.0], censor_dates[f.40022.0.1],censor_dates[f.40022.0.2],na.rm=T))) Note that there are subjects with unknown administrative censored date (i.e., no inpatient record). demog %&gt;% filter(is.na(date_admin_censored)) %&gt;% select(f.eid) %&gt;% nrow() For these subjects with missing hospital admission keys, we identify subject’s administrative censoring date using data field 54 of UKB assessment center data. These fields include which city each participant went in for assessment or imaging, and can indicate where we would expect the origins of their inpatient records. Define a mapping from country to administrative censoring date. country_to_censor_date_mapping &lt;- c(wal = as.Date(&quot;2018-02-28&quot;), scot = as.Date(&quot;2021-07-31&quot;), eng = as.Date(&quot;2021-09-30&quot;)) Load the data containing the field 54. Note, subject ID’s are displayed as Inf for privacy reasons. bd &lt;- readRDS(&quot;generated_data/assessment_center_UKB.RDS&quot;) bd %&gt;% head() %&gt;% mutate(f.eid = Inf) The field f.54.0.0 contains codes indicating the city where the initial assessment was taken. We see that there is only one subject that is missing this value. rmid &lt;- bd %&gt;% filter(is.na(f.54.0.0)) rmid %&gt;% mutate(f.eid = Inf) This subject does exist in the demographic table, but all of the fields are missing except for the participant’s ID. demog %&gt;% right_join(rmid) %&gt;% as_vector() %&gt;% .[-1] %&gt;% is.na %&gt;% all Remove this subject from the demographic table. demog &lt;- demog %&gt;% anti_join(rmid) Now, we will use the values in the field f.54.0.0 to find out which city and in turn which country a participant went in for initial assessment. First, load the mapping file from city code to city name. code_to_city_mapping &lt;- read_tsv(&quot;raw_data/f.54.0.0_coding.tsv&quot;) Second, define the mapping from city name to country name. city_to_country_map &lt;- c(Glasgow = &quot;scot&quot;, Edinburgh = &quot;scot&quot;, Newcastle = &quot;eng&quot;, Middlesborough = &quot;eng&quot;, Leeds = &quot;eng&quot;, Sheffield = &quot;eng&quot;, Bury = &quot;eng&quot;, Liverpool = &quot;eng&quot;, Manchester = &quot;eng&quot;, &quot;Stockport (pilot)&quot; = &quot;eng&quot;, Stoke = &quot;eng&quot;, Nottingham = &quot;eng&quot;, Birmingham = &quot;eng&quot;, Oxford = &quot;eng&quot;, Reading = &quot;eng&quot;, Hounslow = &quot;eng&quot;, &quot;Central London&quot; = &quot;eng&quot;, Croydon = &quot;eng&quot;, Bristol = &quot;eng&quot;, Wrexham = &quot;wal&quot;, Swansea = &quot;wal&quot;, Cardiff = &quot;wal&quot;, Barts = &quot;eng&quot;) # hosptial in england Finally, using defined mappings, we fill in missing administrative censoring dates. demog &lt;- demog %&gt;% left_join(bd %&gt;% select(f.eid,`f.54.0.0`)) %&gt;% rename(coding = `f.54.0.0`) %&gt;% left_join(code_to_city_mapping, by = &quot;coding&quot;) %&gt;% mutate(country = city_to_country_map[meaning]) %&gt;% mutate(date_admin_censored = if_else(!is.na(date_admin_censored),date_admin_censored, country_to_censor_date_mapping[country])) attr(demog$date_admin_censored,&quot;names&quot;) &lt;- NULL Next, we Load reformatted raw ICD table which contains subject’s date of death. ICD &lt;- readRDS(&quot;generated_data/ICD_UKB.RDS&quot;) Define: date of death date of lost-to-follow-up age at study initiation date age at second-visit date date censored date_death_tab &lt;- ICD %&gt;% select(f.eid, f.40000.0.0) %&gt;% arrange(f.eid) %&gt;% data.frame() demog &lt;- demog %&gt;% left_join(date_death_tab, by = &quot;f.eid&quot;) %&gt;% rename(date_death = &quot;f.40000.0.0&quot;) %&gt;% rename(date_lost_fu = &quot;f.191.0.0&quot;) demog &lt;- demog %&gt;% mutate(age_init = decimal_date(date_init) - decimal_date(DOB), age_repeat = decimal_date(date_repeat) - decimal_date(DOB)) %&gt;% mutate(date_censored = pmin(date_admin_censored,date_lost_fu,date_death,na.rm = T)) Select specific columns from demographic table. demog_sel &lt;- demog %&gt;% select(f.eid,DOB,SEX, age_init,age_repeat, date_init,date_repeat, date_censored) Save demographic table. Note that this table includes subjects whose genetic and reported sex do not match. saveRDS(demog_sel,&quot;generated_data/pre_demog_sel.RDS&quot;) "],["3-curate-master-ukb-events-table.html", "3 Curate a master UKB event table", " 3 Curate a master UKB event table This chapter gathers different types of fields available in the UKB assessment center data and generates a master event table. We also convert UKB defined special dates to normal dates. We take the following fields (details of which can be searched here) from the UKB assessment center data: first occurrence fields in first_occur_UKB.RDS algorithmically defined outcome fields in demog_UKB.RDS: f.42000.0.0 f.42008.0.0 f.42010.0.0 f.42012.0.0 f.42006.0.0 f.42026.0.0 ICD10 code fields and their date fields in ICD_UKB.RDS: starts with f.41270 (ICD10 code) starts with f.41280 (ICD10 code event date) starts with f.40001 (ICD10 code primary death) starts with f.40002 (ICD10 code secondary death) starts with f.40000 (ICD10 code death date) OPCS4 code fields in OPCS_procedures_UKB.RDS: starts with f.41272 (OPCS4 code) starts with f.41282 (OPCS4 code event date) self-reported condition field in demog_UKB.RDS: starts with f.20002 (self-reported condition code) starts with f.20008 (self-reported condition code event date) self-reported operation field in demog_UKB.RDS: starts with f.20004 (self-reported operation code) starts with f.20010 (self-reported operation code event date) In addition to these pre-defined fields, we define a custom field called dr_self which is a combination of the following fields: f.5901.0.0 f.5901.1.0 f.5901.2.0 f.5901.3.0 These fields record age at which diabetic eye disease was diagnosed at four different time points. Using this information and the date of birth of a subject, we define the first occurrence event date for this customized outcome dr_self. Custom fields can be defined by users by combining multiple pre-defined fields. However, dr_self is the only custom outcome we define using the UKB assessment center data and included in the master event table. When converting special dates to “normal” dates, we use the following mapping defined by UKB study: First occurrence, algorithimically defined outcome and OPC4 code event date fields Special date Map 1900-01-01 Missing 1901-01-01 Missing 2037-07-07 Missing 1902-02-02 DOB of a subject 1903-03-03 DOB of a subject Self-reported condition and self-reported operation code event date fields: Special date Map decimal date &lt; 1900 Missing The conversion is carried out by the cleandates() function defined in functions.R. Load packages. library(tidyverse) library(data.table) library(lubridate) source(&quot;functions.R&quot;) Load reformatted raw UKB assessment data for generating a master UKB event table. firstoccurs &lt;- readRDS(&quot;generated_data/first_occur_UKB.RDS&quot;) ICD &lt;- readRDS(&quot;generated_data/ICD_UKB.RDS&quot;) procs &lt;- readRDS(&quot;generated_data/OPCS_procedures_UKB.RDS&quot;) demog &lt;- readRDS(&quot;generated_data/demog_UKB.RDS&quot;) Define the date of birth and gender demog &lt;- demog %&gt;% rename(YOB = f.34.0.0) %&gt;% rename(MOB = f.52.0.0) %&gt;% mutate(DOB = lubridate::make_date(YOB, MOB)) %&gt;% mutate(SEX = as.character(f.31.0.0)) "],["3.1-first-occurrence-event-table-and-algorithmically-defined-outcome-table.html", "3.1 First occurrence event table and algorithmically defined outcome table", " 3.1 First occurrence event table and algorithmically defined outcome table Convert first occurrence data into a long format. firstoccurs_long &lt;- firstoccurs %&gt;% pivot_longer(-f.eid, names_to = &quot;field&quot;, values_to = &quot;event_dt&quot;, values_drop_na = T) Obtain algorithmically defined outcomes from demographic dataset. algo_outcome_fields &lt;- paste0(&quot;f.&quot;,c(&quot;42000&quot;, &quot;42008&quot;, &quot;42010&quot;,&quot;42012&quot;,&quot;42006&quot;, &quot;42026&quot;),&quot;.0.0&quot;) algo_outcome_table_wide &lt;- demog %&gt;% select(f.eid,all_of(algo_outcome_fields)) algo_outcome_table_long &lt;- algo_outcome_table_wide %&gt;% pivot_longer(-f.eid,names_to = &quot;field&quot;,values_to = &quot;event_dt&quot;, values_drop_na = T) Merge algorithmically defined outcome fields in the demographic data with first occurrence data to produce outcome fields table. outcome_fields_table_long &lt;- bind_rows(firstoccurs_long,algo_outcome_table_long) "],["3.2-custom-defined-outcome-for-dr.html", "3.2 Custom defined outcome for DR", " 3.2 Custom defined outcome for DR Define customized outcome for diabetes-related eye disease using demographic dataset. We use 5901 family of fields which include: f.5901.0.0 f.5901.1.0 f.5901.2.0 f.5901.3.0 These fields record age at which DR was diagnosed at four different time points. Here are the steps for defining the first occurrence event data for this outcome: Negative values that indicate incidence but unknown date of the event is converted to a numeric value 999. dr_self = 1 if the event happened, or 0 otherwise. age_dr_self: we take the youngest age at which a person was identified as having DR, and individuals with unknown date of this event is coded as NA. If age is greater than 998, then we are uncertain of when the outcome was actually identified, so they are converted back to NA. dr_self is set to NA for individuals who were identified to have an outcome but with missing age when the outcome was identified. To obtain the date of a DR event, we add DOB (decimal date) and age at which the outcome was identified. custom_outcome_fields_table_wide &lt;- demog %&gt;% mutate(f.5901.0.0 = replace(f.5901.0.0, which(f.5901.0.0 &lt; 0), 999)) %&gt;% mutate(f.5901.1.0 = replace(f.5901.1.0, which(f.5901.1.0 &lt; 0), 999)) %&gt;% mutate(f.5901.2.0 = replace(f.5901.2.0, which(f.5901.2.0 &lt; 0), 999)) %&gt;% mutate(f.5901.3.0 = replace(f.5901.3.0, which(f.5901.3.0 &lt; 0), 999)) %&gt;% mutate(dr_self = as.numeric(!is.na(f.5901.0.0) | !is.na(f.5901.1.0) | !is.na(f.5901.2.0) | !is.na(f.5901.3.0))) %&gt;% mutate(age_dr_self = pmin(f.5901.0.0, f.5901.1.0, f.5901.2.0, f.5901.3.0, na.rm=T)) %&gt;% mutate(age_dr_self = replace(age_dr_self, which(age_dr_self &gt; 998), NA)) %&gt;% mutate(dr_self = replace(dr_self, which(is.na(age_dr_self) &amp; dr_self==1), NA)) %&gt;% mutate(date_dr_self = as.Date(date_decimal(decimal_date(DOB) + age_dr_self))) %&gt;% select(f.eid,date_dr_self) custom_outcome_fields_table_long &lt;- custom_outcome_fields_table_wide %&gt;% pivot_longer(-f.eid, names_to = &quot;field&quot;, values_to = &quot;event_dt&quot;, values_drop_na = T) custom_outcome_fields_table_long &lt;- custom_outcome_fields_table_long %&gt;% mutate(field = ifelse(field == &quot;date_dr_self&quot;, &quot;dr_self&quot;, field)) "],["3.3-icd-9-10.html", "3.3 ICD 9 &amp; 10", " 3.3 ICD 9 &amp; 10 Obtain relevant fields. ICD9_codes &lt;- ICD %&gt;% select(f.eid,starts_with(&#39;f.41271&#39;)) %&gt;% arrange(f.eid) %&gt;% data.frame() ICD9_dates &lt;- ICD %&gt;% select(f.eid,starts_with(&#39;f.41281.&#39;)) %&gt;% arrange(f.eid) %&gt;% data.frame() ICD10_codes &lt;- ICD %&gt;% select(f.eid,starts_with(&#39;f.41270&#39;)) %&gt;% arrange(f.eid) %&gt;% data.frame() ICD10_dates &lt;- ICD %&gt;% select(f.eid,starts_with(&#39;f.41280.&#39;)) %&gt;% arrange(f.eid) %&gt;% data.frame() ICD10_codes_primary_death &lt;- ICD %&gt;% select(f.eid,starts_with(&#39;f.40001&#39;)) %&gt;% arrange(f.eid) %&gt;% data.frame() ICD10_codes_secondary_death &lt;- ICD %&gt;% select(f.eid,starts_with(&#39;f.40002&#39;)) %&gt;% arrange(f.eid) %&gt;% data.frame() ICD10_death_date &lt;- ICD %&gt;% select(f.eid, f.40000.0.0) %&gt;% arrange(f.eid) %&gt;% data.frame() Merge ICD10 primary death and death date tables into a long format. ICD10_codes_primary_death_long &lt;- left_join(ICD10_codes_primary_death %&gt;% pivot_longer(cols=-f.eid),ICD10_death_date,by=&quot;f.eid&quot;) %&gt;% select(-name) %&gt;% rename(code=value,event_dt=`f.40000.0.0`) %&gt;% mutate(type=&quot;ICD10_death_primary&quot;) %&gt;% distinct() Merge ICD10 secondary death and death date tables into a long format. ICD10_codes_secondary_death_long &lt;- left_join(ICD10_codes_secondary_death %&gt;% pivot_longer(cols=-f.eid),ICD10_death_date,by=&quot;f.eid&quot;) %&gt;% select(-name) %&gt;% rename(code=value,event_dt=`f.40000.0.0`) %&gt;% mutate(type=&quot;ICD10_death_secondary&quot;) %&gt;% distinct() Merge ICD10 codes and their event dates tables into a long format. ICD10_codes_long &lt;- merge_long(&quot;f.41270&quot;,&quot;f.41280&quot;,ICD10_codes,ICD10_dates,&quot;ICD10&quot;) %&gt;% distinct() Merge ICD9 codes and their event dates tables into a long format. ICD9_codes &lt;- ICD9_codes %&gt;% mutate_at(vars(f.41271.0.0:f.41271.0.46), as.character) ICD9_codes_long &lt;- merge_long(&quot;f.41271&quot;,&quot;f.41281&quot;,ICD9_codes,ICD9_dates,&quot;ICD9&quot;) %&gt;% distinct() Merge all of the ICD event tables with dates, and then remove observations with no codes (code == NA). ICD_codes_full &lt;- do.call(rbind,list(ICD10_codes_long,ICD9_codes_long,ICD10_codes_primary_death_long,ICD10_codes_secondary_death_long)) %&gt;% filter(!is.na(code)) "],["3.4-opcs4.html", "3.4 OPCS4", " 3.4 OPCS4 OPCS4 event table is procedure codes from hospital admission data. Obtain relevant fields. OPCS4 &lt;- procs %&gt;% select(c(f.eid, starts_with(&#39;f.41272.&#39;))) %&gt;% mutate_if(is.factor, as.character) %&gt;% arrange(f.eid) %&gt;% data.frame() OPCS4dates &lt;- procs %&gt;% select(c(f.eid, starts_with(&#39;f.41282.&#39;))) %&gt;% arrange(f.eid) %&gt;% data.frame() OPCS4_codes_long &lt;- merge_long(&quot;f.41272&quot;,&quot;f.41282&quot;,OPCS4,OPCS4dates,&quot;OPCS4&quot;) %&gt;% distinct() %&gt;% filter(!is.na(code)) "],["3.5-self-reported-conditions.html", "3.5 Self-reported conditions", " 3.5 Self-reported conditions Obatin relevant fields. selfrep_codes &lt;- demog %&gt;% select(c(f.eid, starts_with(&quot;f.20002.&quot;))) %&gt;% arrange(f.eid) %&gt;% data.frame() # can&#39;t be data.table selfrep_dates &lt;- demog %&gt;% select(c(f.eid, starts_with(&quot;f.20008.&quot;))) %&gt;% data.frame() %&gt;% mutate_all(funs(replace(., .&lt;1900, NA))) %&gt;% mutate_at(vars(starts_with(&quot;f.20008.&quot;)), .funs = list(~ lubridate::date_decimal(.))) %&gt;% mutate_at(vars(starts_with(&quot;f.20008.&quot;)), .funs = list(~ as.Date(.))) %&gt;% arrange(f.eid) selfrep_codes_long &lt;- merge_long(&quot;f.20002&quot;,&quot;f.20008&quot;,selfrep_codes,selfrep_dates,&quot;selfrep&quot;) %&gt;% distinct() %&gt;% filter(!is.na(code)) "],["3.6-self-reported-operations.html", "3.6 Self-reported operations", " 3.6 Self-reported operations Obatin relevant fields. selfrep_op_codes &lt;- demog %&gt;% select(c(f.eid, starts_with(&quot;f.20004.&quot;))) %&gt;% arrange(f.eid) %&gt;% data.frame() selfrep_op_dates &lt;- demog %&gt;% select(c(f.eid, starts_with(&quot;f.20010.&quot;))) %&gt;% data.frame() %&gt;% mutate_all(funs(replace(., .&lt;1900, NA))) %&gt;% mutate_at(vars(starts_with(&quot;f.20010.&quot;)), .funs = list(~ lubridate::date_decimal(.))) %&gt;% mutate_at(vars(starts_with(&quot;f.20010.&quot;)), .funs = list(~ as.Date(.))) %&gt;% arrange(f.eid) selfrep_op_codes_long &lt;- merge_long(&quot;f.20004&quot;,&quot;f.20010&quot;,selfrep_op_codes,selfrep_op_dates,&quot;selfrep_op&quot;) %&gt;% distinct() %&gt;% filter(!is.na(code)) "],["3.7-standardize-and-merge-event-tables.html", "3.7 Standardize and merge event tables", " 3.7 Standardize and merge event tables The following event tables are merged to produce a master event table: Outcome field event table (combination of first occurrence event data and algorithmically defined event data from demographic table) ICD10 code event table OPCS4 code event table Self-reported condition code event table Self-reported operation code event table Custom defined event table for DR # Standardize outcome_fields_table_long &lt;- outcome_fields_table_long %&gt;% mutate(type = &quot;outcome_fields&quot;) %&gt;% rename(key=field) ICD_codes_full &lt;- ICD_codes_full %&gt;% mutate(code=as.character(code)) %&gt;% rename(key=code) OPCS4_codes_long &lt;- OPCS4_codes_long %&gt;% rename(key=code) selfrep_codes_long &lt;- selfrep_codes_long %&gt;% mutate(code=as.character(code)) %&gt;% rename(key=code) selfrep_op_codes_long &lt;- selfrep_op_codes_long %&gt;% mutate(code=as.character(code)) %&gt;% rename(key=code) custom_outcome_fields_table_long &lt;- custom_outcome_fields_table_long %&gt;% mutate(type = &quot;custom_fields&quot;) %&gt;% rename(key = field) event_tab &lt;- bind_rows(list(outcome_fields_table_long,ICD_codes_full, OPCS4_codes_long,selfrep_codes_long,selfrep_op_codes_long, custom_outcome_fields_table_long)) Filter out events where the date of event is missing. event_tab &lt;- event_tab %&gt;% filter(!is.na(event_dt)) "],["3.8-convert-ukb-special-dates-into-normal-dates.html", "3.8 Convert UKB special dates into “normal” dates", " 3.8 Convert UKB special dates into “normal” dates Convert special dates to normal dates and then filter out any event with an unknown event date. Note that special dates in self-reported and self-reported operation and custom defined outcome table have already been converted in the above. We convert special dates present in the following event table types: outcome_fields, ICD10, ICD10_death_primary, ICD10_death_secondary and OPCS4. demog_dob &lt;- demog %&gt;% select(f.eid, DOB) event_tab &lt;- event_tab %&gt;% left_join(demog_dob, by = &quot;f.eid&quot;) event_tab$event_dt &lt;- cleandates(event_tab$event_dt,event_tab$DOB) event_tab &lt;- event_tab %&gt;% select(-DOB) %&gt;% filter(!is.na(event_dt)) Save the master event table. Note that this table includes subjects whose genetic and reported sex do not match. saveRDS(event_tab,&quot;generated_data/pre_all_ukb_events_tab.RDS&quot;) "],["4-exclude-sex-mismatch-subjects.html", "4 Filter out subjects with sex mismatch", " 4 Filter out subjects with sex mismatch We exclude any subjects who have mismatch between self-reported sex and genetically determined sex from both processed demographic data and the master event table. The ID’s of subjects with sex mismatch will be generated and later be used in preparing a primary care data in the next chapter. Load packages. library(tidyverse) library(data.table) library(lubridate) Load the reformatted UKB assessment center data containing information about subject’s genetically determined sex. The object name of the dataset is sampleqc. The column name containing the genetically determined sex of subjects is genetic_sex. sampleqc &lt;- readRDS(&quot;generated_data/sampleQC_UKB.RDS&quot;) Load curated master ukb event table and demographic table. pre_demog_sel &lt;- readRDS(&quot;generated_data/pre_demog_sel.RDS&quot;) pre_all_ukb_events_tab &lt;- readRDS(&quot;generated_data/pre_all_ukb_events_tab.RDS&quot;) Get subject ID’s that should be excluded because of mismatch in self-reported sex and genetically determined sex. Note that everyone in demographic table has self-reported sex information. However, if a subject is missing genetically determined sex information, then we cannot acertain whether there is a mismatch. Thus, these patients are assumed to have consistent sex information. sex_mismatch_subject_ids &lt;- pre_demog_sel %&gt;% select(f.eid,SEX) %&gt;% full_join(sampleqc %&gt;% select(f.eid,genetic_sex)) %&gt;% filter(SEX != genetic_sex) %&gt;% .$f.eid Filter the demographic table. demog_sel &lt;- pre_demog_sel %&gt;% filter(!(f.eid %in% sex_mismatch_subject_ids)) Filter the master event table. all_ukb_events_tab &lt;- pre_all_ukb_events_tab %&gt;% filter(!(f.eid %in% sex_mismatch_subject_ids)) Save sex mismatch subject ID’s and filtered demographic table and the master event table. saveRDS(sex_mismatch_subject_ids,&quot;generated_data/sex_mismatch_subject_ids.RDS&quot;) saveRDS(demog_sel,&quot;generated_data/demog_selected.RDS&quot;) saveRDS(all_ukb_events_tab,&quot;generated_data/all_ukb_events_tab.RDS&quot;) "],["5-prep-pcp-data.html", "5 Prepare UKB Primary Care Data", " 5 Prepare UKB Primary Care Data The primary care data contain clinical information of approximately 500,000 patients on their visits to primary care physicians. A reason for a visit is recorded as a code. The date of visit associated with the code is also available. We accomplish the following in this chapter: Convert special dates to their mapping Generate subject ID file (used later for excluding control subjects when phenotyping DR and CKD) Exclude subjects with sex mismatch (although the number of unique subjects remain the same after applying sex mismatch filtering) We use the following mapping which is identical to the one we used for preparing the master event table in chapter 3: Special date Map 1900-01-01 Missing 1901-01-01 Missing 2037-07-07 Missing 1902-02-02 DOB of a subject 1903-03-03 DOB of a subject The primary care data is entire_gp_clinical_30March2021_formatted.txt in raw_data folder. The data can be downloaded by approved researchers from the UKB Record Repository if you have requested field 42040. Load packages and a file containing functions. library(data.table) library(tidyverse) source(&quot;functions.R&quot;) Import primary care data. gp_clinical &lt;- fread(&quot;raw_data/entire_gp_clinical_30March2021.txt&quot;) Fix the date format so that other scripts can use it more easily. gp_clinical$event_dt &lt;- as.Date(gp_clinical$event_dt, tryFormats = &quot;%d/%m/%Y&quot;) Create code and terminology fields in place of read_2 and read_3 fields. gp_clinical &lt;- gp_clinical %&gt;% mutate(code = ifelse(read_2 != &quot;&quot;, read_2, read_3)) %&gt;% mutate(terminology = ifelse(read_2 != &quot;&quot;, &quot;read2&quot;, &quot;read3&quot;)) %&gt;% select(-read_2, -read_3) %&gt;% distinct() Rename fid (subject id) field. gp_clinical &lt;- gp_clinical %&gt;% rename(f.eid = eid) Load demographic data. demog &lt;- readRDS(&quot;generated_data/demog_selected.RDS&quot;) Add a field indicating whether the date of event is special. gp_clinical$special_dt &lt;- is_special_date(gp_clinical$event_dt) Convert the special dates. demog_dob &lt;- demog %&gt;% select(f.eid, DOB) gp_clinical &lt;- gp_clinical %&gt;% left_join(demog_dob, by = &quot;f.eid&quot;) gp_clinical$event_dt &lt;- cleandates(gp_clinical$event_dt,gp_clinical$DOB) gp_clinical &lt;- gp_clinical %&gt;% select(-DOB) Save subject IDs represented in the primary care data. gp_subject_ids &lt;- gp_clinical$f.eid %&gt;% unique() saveRDS(gp_subject_ids,&quot;generated_data/gp_subject_ids.RDS&quot;) Remove any events with missing dates. gp_clinical &lt;- gp_clinical %&gt;% filter(!is.na(event_dt)) Filter out subjects with sex mismatch. sex_mismatch_subject_ids &lt;- readRDS(&quot;generated_data/sex_mismatch_subject_ids.RDS&quot;) gp_clinical &lt;- gp_clinical %&gt;% filter(!(f.eid %in% sex_mismatch_subject_ids)) Save the primary care data. fwrite(gp_clinical, &quot;generated_data/entire_gp_clinical_30March2021_formatted.txt&quot;, sep=&quot;\\t&quot;, row.names=F, quote=T) "],["6-make-code-dictionary.html", "6 Create a master code dictionary for primary care data", " 6 Create a master code dictionary for primary care data To phenotype events using the primary care data, we need to identify sets of codes that represent clinical outcomes. To identify these codes, we first curate a master code dictionary which contains all of the codes and their meanings associated with clinical events in the primary care data. The master dictionary is a combination dictionaries for Read v2 and Read v3 coding classification schemes. Read v3 is also called Clinical Terms Version 3 (CTV3). Additional Read v3 codings and their meanings are available through a dictionary called “TPP local.” TPP is one of the electronic health care record system suppliers for general practice (primary care) in England. The purpose of curating the master dictionary is to create an outcome-specific dictionary. For example, for phenotyping diabetes, we identify a certain set of codes that are known to indicate diabetes. Since there does not exist a standard, pre-defined list of codes indicating diabetes, we also search the descriptions of the keyword in the dictionary in an attempt to fully capture codes associated with diabetes. This process requires an extensive manual inspection to avoid mistakenly selecting codes that do not actually indicate diabetes. However, once the list of codes specific to diabetes is created, identifying diabetes subjects from the primary care data is straightforward. The identical process is adopted to curate DKD and DR specific code dictionaries. Load packages. library(data.table) library(tidyverse) Import Read v2 code dictionary data. read2_dict_nondrug &lt;- openxlsx::read.xlsx(&quot;raw_data/all_lkps_maps_v3.xlsx&quot;, sheet = &quot;read_v2_lkp&quot;) read2_dict_drug &lt;- openxlsx::read.xlsx(&quot;raw_data/all_lkps_maps_v3.xlsx&quot;, sheet = &quot;read_v2_drugs_lkp&quot;) Combine drug and nondrug Read v2 dictionaries. Keep only read_code and term_description fields. read2_dict &lt;- full_join(read2_dict_drug,read2_dict_nondrug) %&gt;% select(read_code,term_description) Import Read v3 code dictionary data read3_dict &lt;- openxlsx::read.xlsx(&quot;raw_data/all_lkps_maps_v3.xlsx&quot;, sheet = &quot;read_ctv3_lkp&quot;) Note that Read v3 dictionary has identical codes that start with period and without, for example, .9m05 vs 9m05. In the UKB database, the one starting with ‘.’ is never used, so we filter out these codes. read3_dict &lt;- read3_dict %&gt;% select(read_code, term_description) %&gt;% filter(!(grepl(&#39;^\\\\.&#39;, read_code))) We check whether Read v2 and Read v3 codes overlap. It seems all codes in Read v2 dictionary appear in Read v3 dictionary except for the following: read2_dict$read_code[!(read2_dict$read_code %in% read3_dict$read_code)] Import TPP local codes which are also used in primary care data. These begin with ‘Y’ (Note: fread() automatically resolved the parsing error that read_delim() could not, so we used fread() to import the TPP local code data). tpp_local &lt;- fread(&quot;raw_data/tpp_local.txt&quot;) tpp_local %&gt;% head(10) TPP codes do not appear in Read v2 or Read v3 dictionaries. tpp_local %&gt;% filter(code %in% read2_dict$read_code) tpp_local %&gt;% filter(code %in% read3_dict$read_code) Finally, we merge all of the dictionaries. The master dictionary is intended to cover all of the descriptions in Read v2 and Read v3 code dictionaries. Therefore, we expect to see one-to-many mapping from code to descriptions. This will ensure we do not miss descriptions when we phenotype outcomes using the primary care data in later chapters. full_dict &lt;- full_join(read2_dict %&gt;% rename(code = read_code) %&gt;% mutate(terminology=&quot;read2&quot;), read3_dict %&gt;% rename(code = read_code) %&gt;% mutate(terminology=&quot;read3&quot;)) %&gt;% full_join(tpp_local %&gt;% mutate(terminology=&quot;read3&quot;, terminology_note = &quot;TPP Local Code&quot;)) %&gt;% distinct() Save the full code dictionary for primary care events. saveRDS(full_dict,&quot;generated_data/full_dict.RDS&quot;) "],["7-make-outcome-specific-code-dictionary.html", "7 Make outcome-specific code dictionary", " 7 Make outcome-specific code dictionary In this chapter, we create outcome-specific dictionaries. To do this, we define the following: inclusion codes or code patterns exclusion codes or code patterns inclusion keywords or keyword patterns exclusion keywords or keyword patterns Using these, we subset the master dictionary (full_dict.RDS) to generate outcome-specific dictionary. The following are the event tables that require the primary care data and thus require outcome-specific dictionary: Diabetes event table Diabetic eye disease table for capturing diabetic eye disease cases Kidney disease case event table for capturing diabetic kidney disease cases Non-diabetic eye disease table for excluding controls from time-to-event data for DR Kidney disease event table for excluding controls from time-to-event data for DKD We generate the following outcome-specific dictionaries: diabetes specific dictionary diabetic eye disease dictionary kidney disease case dictionary non-diabetic eye disease dictionary kidney disease control exclusion event dictionary Load packages. library(tidyverse) library(data.table) library(readxl) Import the master dictionary. full_dict &lt;- readRDS(&quot;generated_data/full_dict.RDS&quot;) We first define the global exclusion keywords which we will be used to exclude certain codes from all of the outcome-specific dictionaries. These codes are related to the absence of a condition, screening for a condition, normal result for a condition, family history of a condition, various administrative statuses and more, and are not wanted when we capture the codes that are specific to certain outcomes. global_exclusion_keyword_patterns &lt;- &quot; normal| absent|inspection|examination|evaluation|referral|^no |^O/E- no |^O/E - no |excluded|not seen|seen by|not examined|did not attend|assessable|offered|^trauma| trauma|malnutrition|screening for|^FH|family history|interpret|under care|refused|unsuitable|at risk|resolved|disease screening|not indicated|letter|excepted|exception|fear of|education|sharing consent|tumour|pregnancy|gestational|diabetic child|complication of care|steriod-induced|lymphoma|cytomegalovirus|rubella|blastoma|histoplasm|toxoplasm|neoplasm|herpes|tubercul|pediculus| observation$|injury|streptococcal&quot; "],["7.1-prepare-diabetes-code-dictionary.html", "7.1 Prepare diabetes code dictionary", " 7.1 Prepare diabetes code dictionary 7.1.1 Define keywords Define diabetes specific exclusion keywords. dm_specific_exclusion_keyword_patterns &lt;- &quot;|serum|antibody|remission|relative|association member|high risk of diabetes|suspected diabetes|non-diabetes|breath test|questionnaire|risk score|category score|risk calculator|inhibitor function|C-peptide level|factor binding protein 3|stress test|Insulin tolerance test|Urine screening test|X-ray|NHS Diabetes Prevention|Provision of diabetes clinical summary|diabetes mellitus screen|leaflet given|declined|C1-esterase|pituitary|helicobacter|ineligible|invite|invitation|insulinoma|steroid|secondary diabetes|pre-diabet|prediabet|insipid|provision of written information|not required|national audit|diabetes screen|renal diabetes|non-diabet|^diabetic nurse$|^Diabetic liaison nurse$|jamaica|secondary pancreatic diabetes|driving|neonatal|Addison|PABA test|growth factor|Plasma insulin level|key contact|eligibiliby|CHA2DS2|Professional judgement|Diabetes mellitus: no|non diabetic|information prescription|mother has|preg.|bronzed|Diabetes dietitian|Urine Ketone Test|deleted|refuse|gastropathy|pneumon|Frequency of hypoglycaem|^insulin level$|drug-induced|drug induced|hyperglyceridaemia&quot; Define diabetes exclusion keywords. dm_exclusion_keyword_patterns &lt;- paste0(global_exclusion_keyword_patterns,dm_specific_exclusion_keyword_patterns) Define inclusion keywords. dm_inclusion_keyword_patterns &lt;- &quot;diabetic|diabetes|diabeto|insulin|hyperglyc|hypoglyc|glycemic control&quot; 7.1.2 Define codes Define diabetes exclusion codes. dm_exclusion_codes &lt;- c(&quot;ZV653&quot;, &quot;C3760&quot;, &quot;J4z0&quot;, &quot;Y3045&quot;, &quot;7L1L2&quot;, &quot;Y0015&quot;, &quot;X789v&quot;, &quot;Y7ITk&quot;, &quot;Y2200&quot;, &quot;42c..&quot;, &quot;42W..&quot;, &quot;42WZ.&quot;,&quot;66Ae.&quot;, &quot;66Ae0&quot;,&quot;66AF.&quot;,&quot;C1…&quot;,&quot;XaCET&quot;,&quot;XaCEU&quot;, &quot;XaCEV&quot;) dm_exclusion_code_patterns &lt;- paste(c(&quot;^42W&quot;,&quot;^42c&quot;),collapse = &#39;|&#39;) Import diabetes code lists. dm_codelist &lt;- fread(&quot;raw_data/dm_code_lists/opensafely-diabetes-2020-04-15.csv&quot;) %&gt;% full_join(fread(&quot;raw_data/dm_code_lists/opensafely-type-1-diabetes-2020-06-29.csv&quot;) %&gt;% mutate(Category=1)) %&gt;% full_join(fread(&quot;raw_data/dm_code_lists/opensafely-type-2-diabetes-2020-06-29.csv&quot;) %&gt;% mutate(Category=2)) %&gt;% full_join(fread(&quot;raw_data/dm_code_lists/opensafely-diabetes-exeter-group-2020-07-06.csv&quot;) %&gt;% dplyr::rename(CTV3PreferredTermDesc = ctvterm)) %&gt;% dplyr::rename(term_description = CTV3PreferredTermDesc) %&gt;% dplyr::rename(code = CTV3ID) %&gt;% mutate(Category = as.character(Category)) %&gt;% full_join( fread(&quot;raw_data/dm_code_lists/read_diabetescomplications_caliber.txt&quot;) %&gt;% full_join(fread(&quot;raw_data/dm_code_lists/read_diabetes_expanded_caliber.txt&quot;)) %&gt;% full_join(fread(&quot;raw_data/dm_code_lists/read_diabetes_caliber.txt&quot;)) %&gt;% dplyr::rename(code = Clinical_code) %&gt;% dplyr::rename(term_description = Clinical_term) %&gt;% dplyr::rename(Category = `Category_(code)`) ) Define inclusion codes. dm_inclusion_codes &lt;- dm_codelist$code Define additional diabetes code patterns. dm_inclusion_code_patterns &lt;- paste(c(&quot;^66A&quot;,&quot;^C10&quot;,&quot;^F420&quot;),collapse = &#39;|&#39;) 7.1.3 Create diabetes code dictionary Create diabetes code dictionary. dm_dict &lt;- full_dict %&gt;% filter(grepl(dm_inclusion_keyword_patterns, term_description, ignore.case = T)| code %in% dm_inclusion_codes| grepl(dm_inclusion_code_patterns, code)) %&gt;% filter(!grepl(dm_exclusion_keyword_patterns, term_description, ignore.case = T), !(code %in% dm_exclusion_codes), !grepl(dm_exclusion_code_patterns, code)) We want to filter outcome-specific dictionaries to only those codes that actually occur in the primary care data, to expedite review of the terms that we include. First, read in the distinct terms in PC data. terms_actual &lt;- fread(&quot;generated_data/entire_gp_clinical_30March2021_formatted.txt&quot;, select = &quot;code&quot;) %&gt;% distinct() Now, filter the DM dictionary to terms that exist in the PC data. dm_dict_actual &lt;- dm_dict %&gt;% filter(code %in% terms_actual$code) dm_dict_review &lt;- dm_dict_actual %&gt;% distinct(code, term_description) %&gt;% distinct(code, .keep_all = T) Now, map the Read v2 terms in the dictionary to CTV3, and vice versa, to make sure we capture equivalent terms. The term mappings are provided by UKB in Resource 592. map23 &lt;- read_xlsx(&quot;raw_data/all_lkps_maps_v3.xlsx&quot;, sheet=14) map32 &lt;- read_xlsx(&quot;raw_data/all_lkps_maps_v3.xlsx&quot;, sheet=19) read_map &lt;- map32 %&gt;% select(READV3_CODE, READV2_CODE, IS_ASSURED) %&gt;% filter(IS_ASSURED == 1) %&gt;% dplyr::rename(code = READV3_CODE, mapped_code = READV2_CODE) %&gt;% mutate(terminology = &quot;read3&quot;, mapped_terminology=&quot;read2&quot;) %&gt;% select(-IS_ASSURED) %&gt;% rbind( map23 %&gt;% select(READV2_CODE, READV3_CODE) %&gt;% dplyr::rename(code = READV2_CODE, mapped_code = READV3_CODE) %&gt;% mutate(terminology = &quot;read2&quot;, mapped_terminology =&quot;read3&quot;) ) %&gt;% distinct() %&gt;% filter(code != mapped_code) %&gt;% filter(!grepl(&quot;\\\\.\\\\.&quot;, mapped_code) &amp; !grepl(&quot;\\\\.\\\\.&quot;, code)) %&gt;% #remove very broad mappings filter(code %in% terms_actual$code &amp; mapped_code %in% terms_actual$code) #Only keep pairs that exist in gp_clinical Get any additional mapped codes to include in the DM dictionary. dm_terms_map &lt;- left_join(dm_dict_actual, read_map) %&gt;% filter(!is.na(mapped_code)) %&gt;% filter(!(mapped_code %in% dm_dict$code)) %&gt;% arrange(code) %&gt;% select(-terminology_note) %&gt;% left_join(full_dict %&gt;% dplyr::rename(mapped_code = code, mapped_description = term_description, mapped_terminology=terminology)) %&gt;% group_by(mapped_code) %&gt;% slice(1) %&gt;% distinct() %&gt;% filter(!(grepl(&quot;[Dd]rug induced&quot;, mapped_description))) Combine the new terms with the original DM dictionary. dm_dict_final &lt;- rbind(dm_dict_actual, dm_terms_map %&gt;% select(code = mapped_code, term_description = mapped_description, terminology = mapped_terminology, terminology_note) ) Save diabetes code dictionary. saveRDS(dm_dict_final,&quot;generated_data/dm_dict.RDS&quot;) "],["7.2-prepare-diabetic-eye-disease-code-dictionary.html", "7.2 Prepare diabetic eye disease code dictionary", " 7.2 Prepare diabetic eye disease code dictionary 7.2.1 Define keywords Define inclusion keywords. inclusion_keyword_patterns &lt;- &quot;macul|retin|ophthalmic manifestation|ophthalmic complication|cataract|glaucoma|eye disease|diabetic iritis&quot; Define inclusion keywords for case. inclusion_keyword_patterns_case &lt;- &quot;diabetic|diabetes|diabet retinopathy&quot; Define exclusion keywords. exclusion_keyword_patterns &lt;- &quot; no maculopathy|^normal |translocation|cataract screen|retinol|incretin|diabetic retinopathy screening|retinal screening|steroid|drug induced|ratiation induced|branch of|vocational asses|electroretinography|buckling|tamponade|biopsy|retinopexy|cretin|glaucoma screen|pigment|fundoscopy|migraine|Commotio retinae|berlin|angiography|melanocytic macule|melanotic macule|acute retinal necrosis|radiation retinopathy|solar retinopathy|retinal dialysis|toxic maculopathy|eruption|retinacul|Acitretin|tretinoin|alopecia|branch of retinal artery$|rash&quot; exclusion_keywords &lt;- c(&quot;O/E - retina&quot;, &quot;Retinal photography&quot;, &quot;Retinoscopy&quot;, &quot;Senile macular disorder screen&quot;, &quot;Digital imaging of retina&quot;, &quot;[SO]Retina&quot;, &quot;Retinal scan - laser&quot;, &quot;Macula&quot;, &quot;Retina&quot;, &quot;Retinitis&quot;, &quot;Fundus flavimaculatus&quot;, &quot;Macula observation&quot;, &quot;Superior temporal branch of retinal vein&quot;, &quot;Senile macular disorder screening&quot;, &quot;Retinal vein&quot;, &quot;Branch of Retinal vein&quot;,&quot;Retinal artery&quot;,&quot;Limiting membrane of retina&quot;, &quot;Nerve fibre layer of retina&quot;,&quot;Inferior temporal quadrant of retina&quot;,&quot;Central retinal vein&quot;, &quot;Secondary syphilitic chorioretinitis&quot;, &quot;Maculopapular&quot;, &quot;Parafoveal retina&quot;, &quot;Retinal structure&quot;, &quot;Tomaculous neuropathy&quot;, &quot;CMV retinitis&quot;, &quot;Choroidal and retinal structures&quot;, &quot;Retinal arteriole&quot;) Define exclusion keywords for case. exclusion_keyword_patterns_case &lt;- &quot;non-diab|non diab&quot; 7.2.2 Define codes Define inclusion codes. inclusion_code_patterns &lt;- &quot;^F42&quot; inclusion_codes &lt;- c(&quot;F4407&quot;) Define exclusion codes. exclusion_code_patterns &lt;- c(&quot;^hg1|^hh51|^j24|^kaA|^m[5-7]&quot;) 7.2.3 Create diabetic eye disease code dictionary Create eye disease code dictionary. eye_disease_dict &lt;- full_dict %&gt;% filter(grepl(inclusion_keyword_patterns, term_description, ignore.case = T) | grepl(inclusion_code_patterns, code, ignore.case = T) | code %in% inclusion_codes) %&gt;% filter(!grepl(global_exclusion_keyword_patterns, term_description, ignore.case = T) &amp; !grepl(exclusion_keyword_patterns, term_description, ignore.case = T) &amp; !grepl(exclusion_code_patterns, code, ignore.case = F) &amp; !(term_description %in% exclusion_keywords)) Get terms that actually occur in the PC data. eye_disease_actual &lt;- eye_disease_dict %&gt;% filter(code %in% terms_actual$code) Create diabetic eye disease code dictionary. dm_eye_disease_dict &lt;- eye_disease_actual %&gt;% filter(grepl(inclusion_keyword_patterns_case, term_description, ignore.case=T) &amp; !grepl(exclusion_keyword_patterns_case, term_description, ignore.case=T)) Review unique terms. dr_pc_review &lt;- dm_eye_disease_dict %&gt;% distinct(code, term_description) %&gt;% distinct(code, .keep_all = T) See if there are any additional mapped terms. For diabetic retinopathy, there are none. dr_terms_map &lt;- left_join(dm_eye_disease_dict, read_map) %&gt;% filter(!is.na(mapped_code)) %&gt;% filter(!(mapped_code %in% dm_eye_disease_dict$code)) %&gt;% arrange(code) %&gt;% select(-terminology_note) %&gt;% left_join(full_dict %&gt;% dplyr::rename(mapped_code = code, mapped_description = term_description, mapped_terminology=terminology)) %&gt;% group_by(mapped_code) %&gt;% slice(1) %&gt;% distinct() dr_terms_map Generate non-diabetic eye disease code dictionary. nondm_eye_disease_dict &lt;- eye_disease_actual %&gt;% filter(!(code %in% dm_eye_disease_dict$code)) Review non-diabetic eye disease terms. nondm_eye_review &lt;- nondm_eye_disease_dict %&gt;% distinct(code, term_description) %&gt;% distinct(code, .keep_all = T) See if there are any additional mapped terms. nondm_eye_disease_terms_map &lt;- left_join(nondm_eye_disease_dict, read_map) %&gt;% filter(!is.na(mapped_code)) %&gt;% filter(!(mapped_code %in% nondm_eye_disease_dict$code)) %&gt;% arrange(code) %&gt;% select(-terminology_note) %&gt;% left_join(full_dict %&gt;% dplyr::rename(mapped_code = code, mapped_description = term_description, mapped_terminology=terminology)) %&gt;% group_by(mapped_code) %&gt;% slice(1) %&gt;% distinct() %&gt;% filter(!grepl(&quot;hypertensive&quot;, mapped_description)) nondm_eye_disease_terms_map Combine the new terms with the original non-diabetic eye disease dictionary. nondm_eye_disease_dict_final &lt;- rbind(nondm_eye_disease_dict, nondm_eye_disease_terms_map %&gt;% select(code = mapped_code, term_description = mapped_description, terminology = mapped_terminology, terminology_note) ) Save diabetic eye disease code dictionary and non-diabetic eye disease code dictionary. saveRDS(dm_eye_disease_dict,&quot;generated_data/dm_eye_disease_dict.RDS&quot;) saveRDS(nondm_eye_disease_dict_final,&quot;generated_data/nondm_eye_disease_dict.RDS&quot;) "],["7.3-prepare-diabetic-kidney-disease-code-dictionary.html", "7.3 Prepare diabetic kidney disease code dictionary", " 7.3 Prepare diabetic kidney disease code dictionary 7.3.1 Define Keywords Define inclusion keywords. inclusion_keyword_patterns &lt;- &quot;chronic kidney|chronic renal|ckd|glomerul|kidney failure|renal failure|uraemi|uremi|nephropath|proteinuri|albuminuri|nephrotic|nephrosis|nephritic|renal manifestation|renal complication|end stage renal|end stage kidney|esrd&quot; Define inclusion keywords for case. inclusion_keyword_patterns_case &lt;- &quot;stage 3|stage 4|stage 5|end stage|chronic renal failure|chronic kidney failure|chronic uraemia|G3|G4|G5|A3|diabetes|diabetic|persistent proteinur|persistent albuminur|persistent microalbuminur|persistent macroalbuminur|ns - nephrotic syndrome$|^nephrotic syndrome NOS$&quot; inclusion_keywords_case &lt;- c(&quot;Nephrotic syndrome&quot;) Define exclusion keywords. exclusion_keyword_patterns &lt;- &quot;nephritic factor|antibody|disease screening|rate testing|predicted stage|acute|induced by|metals|cadmium|lead|mercury|toxic|abortion|pregnancy|gestational|delivery|calculated by|^glomerular filtration rate$|nephropathy screen|invite|incipient|rate using|laboratory study|monitoring administration|Glomerular function test|benign|haemolytic|B12 deficiency|pyonephrosis|analgesic|Exercise|Adrenal|test strip|proteinuria negative|test urine sample&quot; 7.3.2 Define codes Import diabetic kidney disease code lists and define inclusion codes. ckd_codelist &lt;- fread(&quot;raw_data/kd_code_lists/opensafely-kidney-transplant-2020-07-15.csv&quot;) %&gt;% full_join(fread(&quot;raw_data/kd_code_lists/opensafely-dialysis-2020-07-16.csv&quot;)) %&gt;% full_join(fread(&quot;raw_data/kd_code_lists/opensafely-chronic-kidney-disease-2020-04-14.csv&quot;)) %&gt;% dplyr::rename(term_description = CTV3PreferredTermDesc) %&gt;% dplyr::rename(code = CTV3ID) inclusion_codes &lt;- ckd_codelist$code 7.3.3 Create diabetic kidney disease code dictionary Create kidney disease dictionary. kidney_disease_dict &lt;- full_dict %&gt;% filter(grepl(inclusion_keyword_patterns,term_description, ignore.case = T) | code %in% inclusion_codes) %&gt;% filter(!grepl(global_exclusion_keyword_patterns, term_description, ignore.case = T) &amp; !grepl(exclusion_keyword_patterns, term_description, ignore.case = T)) Filter to terms that actually appeared in the PC data to expedite review. kidney_disease_actual &lt;- kidney_disease_dict %&gt;% filter(code %in% terms_actual$code) Generate kidney disease dictionary. kidney_disease_case_dict &lt;- kidney_disease_actual %&gt;% filter(grepl(inclusion_keyword_patterns_case,term_description,ignore.case = T)| term_description %in% inclusion_keywords_case) Review terms. kidney_disease_case_review &lt;- kidney_disease_case_dict %&gt;% distinct(code, term_description) %&gt;% distinct(code, .keep_all = T) See if there are any additional mapped terms. For kidney disease cases, there are none. kidney_disease_case_terms_map &lt;- left_join(kidney_disease_case_dict, read_map) %&gt;% filter(!is.na(mapped_code)) %&gt;% filter(!(mapped_code %in% kidney_disease_case_dict$code)) %&gt;% arrange(code) %&gt;% select(-terminology_note) %&gt;% left_join(full_dict %&gt;% dplyr::rename(mapped_code = code, mapped_description = term_description, mapped_terminology=terminology)) %&gt;% group_by(mapped_code) %&gt;% slice(1) %&gt;% distinct() kidney_disease_case_terms_map Generate kidney disease control exclusion dictionary. kidney_disease_control_exclusion_dict &lt;- kidney_disease_actual %&gt;% filter(!(code %in% kidney_disease_case_dict$code)) Review terms. kidney_disease_control_exclusion_review &lt;- kidney_disease_control_exclusion_dict %&gt;% distinct(code, term_description) %&gt;% distinct(code, .keep_all =T) See if there are any additional mapped terms. kidney_disease_control_exclusion_terms_map &lt;- left_join(kidney_disease_control_exclusion_dict, read_map) %&gt;% filter(!is.na(mapped_code)) %&gt;% filter(!(mapped_code %in% kidney_disease_control_exclusion_dict$code)) %&gt;% arrange(code) %&gt;% select(-terminology_note) %&gt;% left_join(full_dict %&gt;% dplyr::rename(mapped_code = code, mapped_description = term_description, mapped_terminology=terminology)) %&gt;% group_by(mapped_code) %&gt;% slice(1) %&gt;% distinct() kidney_disease_control_exclusion_terms_map Combine the new terms with the original kidney disease control exclusion dictionary. kidney_disease_control_exclusion_dict_final &lt;- rbind(kidney_disease_control_exclusion_dict, kidney_disease_control_exclusion_terms_map %&gt;% select(code = mapped_code, term_description = mapped_description, terminology = mapped_terminology, terminology_note) ) Save kidney disease case dictionary and kidney disease control exclusion code dictionary. saveRDS(kidney_disease_case_dict,&quot;generated_data/kidney_disease_case_dict.RDS&quot;) saveRDS(kidney_disease_control_exclusion_dict_final,&quot;generated_data/kidney_disease_control_exclusion_dict.RDS&quot;) "],["8-phenotype-outcomes-ukb.html", "8 Phenotype outcome and control exclusion events using UKB assessment center data", " 8 Phenotype outcome and control exclusion events using UKB assessment center data In this chapter, we use the master UKB event table created in chapter 3 to generate different outcome event tables. We phenotype the following outcomes: Diabetes (DM) Myocardial Infarction (MI) Unstable Angina (UA) Ischemic Stroke (IS) Hemorrhagic Stroke (HS) Stroke (ST) PCI Composite CVD Diabetic retinopathy (DR) Diabetic kidney disease (DKD) The following event tables will also be created to exclude certain controls from time-to-event tables in later chapters: Diabetic eye disease control exclusion events Diabetic kidney disease control exclusion events Cardiovascular control exclusion events Cerebrovascular control exclusion events Non-coronary revascularization control exclusion events The general phenotyping procedure for complication outcomes and control exclusion outcomes are the same. All we have to do is to define patterns we want to search and match these patterns from the master UKB event table. The pattern searching is abstracted away in a function get_phenotype_tab() in functions.R. The function searches certain regular expression patterns corresponding to outcomes from the master UKB event table and outputs the table containing all of the events matching the patterns. The following are the types of patterns the function accepts: UKB-defined field patterns custom-defined field patterns ICD10 code patterns (also accepts more specific ICD10 codes for primary death and secondary death events) OPCS4 code patterns self-reported condition code patterns self-reported operation code patterns The UKB-defined field patterns match fields that are associated with first occurrence fields and algorithimically defined fields as defined by UKB study. The custom field pattern matches a custom field defined in chapter 3. As a reminder, the only custom field we have defined is dr_self used in phenotyping diabetes related eye disease. The code patterns including ICD10, OPCS4, self-reported condition and self-reported operation match the codes that represent some clinical events. Thus, to phenotype an outcome, one should first identify the fields and codes associated with an outcome, define the patterns which are one of the inputs to get_phenotype_tab(). Internally, get_phenotype_tab function uses grepl function in dplyr package to filter the master event table. Load packages and functions. library(tidyverse) library(data.table) source(&quot;functions.R&quot;) Import the master event table. event_tab &lt;- readRDS(&quot;generated_data/all_ukb_events_tab.RDS&quot;) "],["8.1-phenotype-outcomes.html", "8.1 Phenotype outcomes", " 8.1 Phenotype outcomes 8.1.1 DM Outcome fields: f.130706.0.0: the date of first occurrence of Type 1 diabetes f.130708.0.0: the date of first occurrence of Type 2 diabetes f.130714.0.0: the date of first occurrence of diabetes of unspecified type dm_field_patterns &lt;- &quot;130706|130708|130714&quot; Get DM event table and first occurrence DM event table. dm_ukb &lt;- get_phenotype_tab(field_patterns = dm_field_patterns,event_tab = event_tab,firstoccur = F) dm_firstoccur_ukb &lt;- get_phenotype_tab(field_patterns = dm_field_patterns,event_tab = event_tab,firstoccur = T) Categorize diabetes event to either Type1, Type2 or Uncertain in a new field dm_type. dm_ukb &lt;- dm_ukb %&gt;% mutate(dm_type = ifelse(grepl(&quot;130706&quot;, key), &quot;Type1&quot;, ifelse(grepl(&quot;130708&quot;, key), &quot;Type2&quot;,&quot;Uncertain&quot;))) saveRDS(dm_ukb,&quot;generated_data/dm_ukb.RDS&quot;) saveRDS(dm_firstoccur_ukb,&quot;generated_data/dm_firstoccur_ukb.RDS&quot;) 8.1.2 MI Outcome fields: f.131298.0.0: the date of first occurrence of MI f.131300.0.0: the date of subsequent occurrence of MI f.42000.0.0: the date of algorithmically defined MI outcome ICD10 code prefixes: I21 I22 I23 Define patterns to search. mi_field_patterns &lt;- &quot;131298|131300|42000&quot; mi_icd10_patterns &lt;- &quot;^I21|^I22|^I23&quot; Get MI event table and first occurrence MI event table. mi_ukb &lt;- get_phenotype_tab(field_patterns = mi_field_patterns, icd10_patterns_any = mi_icd10_patterns,event_tab = event_tab,firstoccur = F) mi_firstoccur_ukb &lt;- get_phenotype_tab(field_patterns = mi_field_patterns, icd10_patterns_any = mi_icd10_patterns,event_tab = event_tab,firstoccur = T) saveRDS(mi_ukb,&quot;generated_data/mi_ukb.RDS&quot;) saveRDS(mi_firstoccur_ukb,&quot;generated_data/mi_firstoccur_ukb.RDS&quot;) 8.1.3 Unstable Angina ICD10 code prefixes: I200 unstable_angina_icd10_patterns &lt;- &quot;I200&quot; Get unstable angina table and first occurrence unstable angina event table. unstable_angina_ukb &lt;- get_phenotype_tab(icd10_patterns_any = unstable_angina_icd10_patterns, event_tab = event_tab,firstoccur = F) unstable_angina_firstoccur_ukb &lt;- get_phenotype_tab(icd10_patterns_any = unstable_angina_icd10_patterns, event_tab = event_tab,firstoccur = T) saveRDS(unstable_angina_ukb,&quot;generated_data/unstable_angina_ukb.RDS&quot;) saveRDS(unstable_angina_firstoccur_ukb,&quot;generated_data/unstable_angina_firstoccur_ukb.RDS&quot;) 8.1.4 Ischemic Stroke Outcome fields: - 131366: Date I63 first reported (cerebral infarction) - 42008: algorithmically defined outcome for ischemic stroke ICD10 code prefixes: - I63 Self-reported condition codes: - 1583 Define patterns to search. stroke_infarct_field_patterns &lt;- &quot;131366|42008&quot; stroke_infarct_icd10_patterns &lt;- &quot;^I63&quot; stroke_infarct_selfrep_patterns &lt;- &quot;^1583$&quot; Get IS event table and first occurrence IS event table. stroke_infacrt_ukb &lt;- get_phenotype_tab(field_patterns = stroke_infarct_field_patterns, icd10_patterns_any = stroke_infarct_icd10_patterns, selfrep_patterns = stroke_infarct_selfrep_patterns, event_tab = event_tab,firstoccur = F) stroke_infacrt_firstoccur_ukb &lt;- get_phenotype_tab(field_patterns = stroke_infarct_field_patterns, icd10_patterns_any = stroke_infarct_icd10_patterns, selfrep_patterns = stroke_infarct_selfrep_patterns, event_tab = event_tab,firstoccur = T) saveRDS(stroke_infacrt_ukb,&quot;generated_data/stroke_infarct_ukb.RDS&quot;) saveRDS(stroke_infacrt_firstoccur_ukb,&quot;generated_data/stroke_infarct_firstoccur_ukb.RDS&quot;) 8.1.5 Hemorrhagic Stroke Outcome fields: 131360: Subarachnoid Hemorrhage 131362: Intracerebral Hemorrhage 131364: Other non-traumatic Hemorrhage, 42010: Intracerebral Hemorrhage 42012: Subarachnoid Hemorrhage ICD10 code prefixes: - I60 - I61 - I62 Self-reported condition codes: - 1086 Define patterns to search. stroke_hem_field_patterns &lt;- &quot;131360|131362|131364|42010|42012&quot; stroke_hem_icd10_patterns &lt;- &quot;^I60|^I61|^I62&quot; stroke_hem_selfrep_patterns &lt;- &quot;^1086$&quot; Get HS event table and first occurrence HS table. stroke_hem_ukb &lt;- get_phenotype_tab(field_patterns = stroke_hem_field_patterns, icd10_patterns_any = stroke_hem_icd10_patterns, selfrep_patterns = stroke_hem_selfrep_patterns, event_tab = event_tab,firstoccur = F) stroke_hem_firstoccur_ukb &lt;- get_phenotype_tab(field_patterns = stroke_hem_field_patterns, icd10_patterns_any = stroke_hem_icd10_patterns, selfrep_patterns = stroke_hem_selfrep_patterns, event_tab = event_tab,firstoccur = T) saveRDS(stroke_hem_ukb,&quot;generated_data/stroke_hem_ukb.RDS&quot;) saveRDS(stroke_hem_firstoccur_ukb,&quot;generated_data/stroke_hem_firstoccur_ukb.RDS&quot;) 8.1.6 Stroke Outcome fields: - 42006: unspecified stroke - 131368: unspecified stroke ICD10 code prefix - I64 Self-reported condition codes: - 1081 Outcome tables: - recurrent ischemic stroke event table - recurrent hemorrhagic stroke event table Define patterns to search. stroke_unspec_field_patterns &lt;- &quot;42006|131368&quot; stroke_unspec_icd10_patterns &lt;- &quot;^I64&quot; stroke_other_selfrep_patterns &lt;- &quot;^1081$&quot; Get stroke event table stroke_infarct_hem_ukb &lt;- full_join(stroke_infacrt_ukb,stroke_hem_ukb) %&gt;% arrange(f.eid,event_dt) stroke_unspec_ukb &lt;- get_phenotype_tab(field_patterns = stroke_unspec_field_patterns, icd10_patterns_any = stroke_unspec_icd10_patterns, event_tab = event_tab,firstoccur = F) stroke_other_ukb &lt;- get_phenotype_tab(selfrep_patterns = stroke_other_selfrep_patterns, event_tab = event_tab,firstoccur = F) stroke_ukb &lt;- stroke_infarct_hem_ukb %&gt;% full_join(stroke_unspec_ukb, by = c(&quot;f.eid&quot;,&quot;event_dt&quot;)) %&gt;% full_join(stroke_other_ukb, by = c(&quot;f.eid&quot;,&quot;event_dt&quot;)) %&gt;% arrange(f.eid,event_dt) Get first occurrence stroke event table stroke_firstoccur_ukb &lt;- stroke_ukb %&gt;% group_by(f.eid) %&gt;% arrange(event_dt) %&gt;% slice(1) saveRDS(stroke_ukb,&quot;generated_data/stroke_ukb.RDS&quot;) saveRDS(stroke_firstoccur_ukb,&quot;generated_data/stroke_firstoccur_ukb.RDS&quot;) 8.1.7 PCI OPCS4 codes: - K40, K41, K42, K43, K44, K45, K46, K483, K49, K501, K75, K76 Self-reported operation codes: - 1070 (Coronary Angioplasty) - 1095 (Coronary bypass grafts) Define patterns to search. # OPCS patterns start with &#39;K&#39; so do not have to start the pattern with &#39;^&#39; pci_opcs_patterns &lt;- &quot;K40|K41|K42|K43|K44|K45|K46|K483|K49|K501|K75|K76&quot; pci_selfrep_op_patterns &lt;- &quot;^1070$|^1095$&quot; Get PCI event table and first occurrence PCI event table. pci_ukb &lt;- get_phenotype_tab(opcs_patterns = pci_opcs_patterns, selfrep_op_patterns = pci_selfrep_op_patterns, event_tab = event_tab,firstoccur = F) pci_firstoccur_ukb &lt;- get_phenotype_tab(opcs_patterns = pci_opcs_patterns, selfrep_op_patterns = pci_selfrep_op_patterns, event_tab = event_tab,firstoccur = T) saveRDS(pci_ukb,&quot;generated_data/pci_ukb.RDS&quot;) saveRDS(pci_firstoccur_ukb,&quot;generated_data/pci_firstoccur_ukb.RDS&quot;) 8.1.8 CVD death ICD10 code prefixes (primary death): -I* Define patterns to search. cvd_death_icd10_death_primary_patterns &lt;- &quot;^I&quot; Get CVD death event table cvd_death_ukb &lt;- get_phenotype_tab(icd10_patterns_pd = cvd_death_icd10_death_primary_patterns, event_tab = event_tab,firstoccur = F) saveRDS(cvd_death_ukb,&quot;generated_data/cvd_death_ukb.RDS&quot;) 8.1.9 Composite CVD Composite CVD was defined to be any of the following events: MI IS UA PCI CVD death Get compositie CVD event table and first occurrence composite CVD event table. cvd_ukb &lt;- mi_ukb %&gt;% full_join(stroke_infacrt_ukb) %&gt;% full_join(unstable_angina_ukb) %&gt;% full_join(pci_ukb) %&gt;% full_join(cvd_death_ukb) %&gt;% distinct() %&gt;% arrange(f.eid,event_dt) cvd_firstoccur_ukb &lt;- cvd_ukb %&gt;% group_by(f.eid) %&gt;% arrange(event_dt) %&gt;% slice(1) saveRDS(cvd_ukb,&quot;generated_data/cvd_ukb.RDS&quot;) saveRDS(cvd_firstoccur_ukb,&quot;generated_data/cvd_firstoccur_ukb.RDS&quot;) 8.1.10 DR ICD10 codes: E1*.3: Diabetes Mellitus with Ophthalmic Complications H36.0: Diabetic Retinopathy H28.0: Diabetic Cataract ICD9 codes: 2504: Diabetes with Ophthalmic manifestations 3620: Diabetic retinopathy Self-reported condition codes: 1276 Custom defined fields: dr_self: the date of DR diagnosis. As a reminder dr_self was produced by combining information from the fields f.5901.0.0, f.5901.1.0, f.5901.2.0 and f.5901.3.0 which record age of subjects at which DR was diagnosed at four different time points. Please see chapter 3 for details. Define patterns. dr_icd10 &lt;- &quot;E103|E113|E133|E143|H360|H280&quot; dr_icd9 &lt;- &quot;^2504|^3620&quot; dr_self &lt;- &quot;1276&quot; dr_custom &lt;- &quot;dr_self&quot; Get first occurrence DR event table. dr_firstoccur_ukb &lt;- get_phenotype_tab(icd10_patterns_any = dr_icd10, icd9_patterns_any = dr_icd9, selfrep_patterns = dr_self, custom_field_patterns = dr_custom, event_tab = event_tab,firstoccur = T) saveRDS(dr_firstoccur_ukb,&quot;generated_data/dr_firstoccur_ukb.RDS&quot;) 8.1.11 DKD Outcome fields: 42026: algorithmically defined End-Stage Renal Disease (ESRD) ICD10 codes: E1.2: Diabetes Mellitus with renal complication N18[0345]: CKD Stage 3-5, end stage N083: Glomerular disorders in Diabetes Mellitus ICD9 codes: - 2503: Diabetes with renal manifestations - 5859: Renal failure Self-reported condition codes: 1607 Define patterns. dkd_field_patterns &lt;- &quot;42026&quot; dkd_icd10 &lt;- &quot;E102|E112|E132|E142|N180|N183|N184|N185|N083&quot; dkd_icd9 &lt;- &quot;^2503|^5859&quot; dkd_self &lt;- &quot;1607&quot; Get DKD event table and first occurrence DKD event table. dkd_ukb &lt;- get_phenotype_tab(field_patterns = dkd_field_patterns, icd10_patterns_any = dkd_icd10, icd9_patterns_any = dkd_icd9, selfrep_patterns = dkd_self, event_tab = event_tab,firstoccur = F) dkd_firstoccur_ukb &lt;- get_phenotype_tab(field_patterns = dkd_field_patterns, icd10_patterns_any = dkd_icd10, icd9_patterns_any = dkd_icd9, selfrep_patterns = dkd_self, event_tab = event_tab,firstoccur = T) saveRDS(dkd_ukb,&quot;generated_data/dkd_ukb.RDS&quot;) saveRDS(dkd_firstoccur_ukb,&quot;generated_data/dkd_firstoccur_ukb.RDS&quot;) "],["8.2-phenotype-control-exclusion-events.html", "8.2 Phenotype control exclusion events", " 8.2 Phenotype control exclusion events 8.2.1 Cardiovascular control exclusion events Define patterns. exclude_ctrl_cardio_icd10 &lt;- &quot;I2|I3|I5|I6|I7&quot; exclude_ctrl_cardio_self &lt;- &quot;1074|1076|1077|1078|1079|1080|1471|1489|1490|1492|1584|1585|1586|1587|1588|1589|1590|1591|1592&quot; exclude_ctrl_cardio_selfop &lt;- &quot;1069|1096|1097|1098|1099|1100|1101|1104|1523|1553|1554&quot; Get cardiovascular control exclusion event table. cardio_control_exclusion_events &lt;- get_phenotype_tab(icd10_patterns_any = exclude_ctrl_cardio_icd10, selfrep_patterns = exclude_ctrl_cardio_self, selfrep_op_patterns = exclude_ctrl_cardio_selfop,event_tab = event_tab,firstoccur = F) saveRDS(cardio_control_exclusion_events,&quot;generated_data/cardio_control_exclusion_events_ukb.RDS&quot;) 8.2.2 Cerebrovascular control exclusion events Define patterns. exclude_ctrl_cereb_icd10 &lt;- &quot;G45|G46|I65|I66|I67|I68|I69&quot; exclude_ctrl_cereb_self &lt;- &quot;1082&quot; Get cerebrovascular control exclusion event table. cerebro_control_exclusion_events &lt;- get_phenotype_tab(icd10_patterns_any = exclude_ctrl_cereb_icd10, selfrep_patterns = exclude_ctrl_cereb_self,event_tab = event_tab,firstoccur = F) saveRDS(cerebro_control_exclusion_events,&quot;generated_data/cerebro_control_exclusion_events_ukb.RDS&quot;) 8.2.3 Non-coronary revascularization procedure control exclusion events Define patterns. other_revasc_selfop &lt;- &quot;1071|1102|1105|1107|1108|1109|1110&quot; Get non-coronary revascularization procedure control exclusion event table. other_revas_control_exclusion_events &lt;- get_phenotype_tab(selfrep_op_patterns = other_revasc_selfop, event_tab = event_tab, firstoccur = F) saveRDS(other_revas_control_exclusion_events,&quot;generated_data/other_revas_control_exclusion_events_ukb.RDS&quot;) 8.2.4 Renal disease control exclusion events Define patterns. exclude_ctrl_renal_icd10 &lt;- &quot;N0|N1|N2|Z49|Z992&quot; exclude_ctrl_renal_icd9 &lt;- &quot;^58[0-9]|^59[1-4]|^590[23]|^V420|^V454|^V560|^V568&quot; exclude_ctrl_renal_self &lt;- &quot;1192|1193|1194|1519|1520|1608|1609&quot; exclude_ctrl_renal_selfop &lt;- &quot;1195|1487&quot; exclude_ctrl_renal_opcs &lt;- &quot;M01|M02|M03|X40|X41|X42&quot; Get renal diseasae control exclusion event table. dkd_control_exclusion_events &lt;- get_phenotype_tab(icd10_patterns_any = exclude_ctrl_renal_icd10, icd9_patterns_any = exclude_ctrl_renal_icd9, selfrep_patterns = exclude_ctrl_renal_self, selfrep_op_patterns = exclude_ctrl_renal_selfop, opcs_patterns = exclude_ctrl_renal_opcs,event_tab = event_tab,firstoccur = F) saveRDS(dkd_control_exclusion_events,&quot;generated_data/dkd_control_exclusion_events_ukb.RDS&quot;) 8.2.5 Eye disease control exclusion events Define patterns. exclude_eye_icd10 &lt;- &quot;H25|H26|H28|H34|H35|H36|H40|H42&quot; exclude_eye_icd9 &lt;- &quot;^36[256]&quot; exclude_eye_self &lt;- &quot;1275|1277|1278|1281|1282|1527|1538|1530&quot; exclude_eye_selfop &lt;- &quot;1434|1435|1436|1437&quot; Get eye disease control exclusion event table. dr_control_exclusion_events &lt;- get_phenotype_tab(icd10_patterns_any = exclude_eye_icd10, icd9_patterns_any = exclude_eye_icd9, selfrep_patterns = exclude_eye_self, selfrep_op_patterns = exclude_eye_selfop,event_tab = event_tab,firstoccur = F) saveRDS(dr_control_exclusion_events,&quot;generated_data/dr_control_exclusion_events_ukb.RDS&quot;) "],["9-phenotype-outcomes-pcp.html", "9 Phenotype outcomes using primary care data", " 9 Phenotype outcomes using primary care data In this chapter, we use outcome-specific dictionaries generated in chapter 7 and the primary care data prepared in chapter 5 to generate the following outcomes and control exclusion events: diabetes diabetic kidney disease diabetic retinopathy kidney disease control exclusion events non-diabetic eye disease events The event tables are created by subsetting the primary care data with a corresponding outcome-specific dictionary. "],["9.1-phenotype-outcome-events.html", "9.1 Phenotype outcome events", " 9.1 Phenotype outcome events Load packages and reference.R which will be used in phenotyping diabetes (details in DM section below). library(tidyverse) library(data.table) source(&quot;reference.R&quot;) Import primary care data. pc &lt;- fread(&quot;generated_data/entire_gp_clinical_30March2021_formatted.txt&quot;) Import outcome-specific dictionaries. dm_dict &lt;- readRDS(&quot;generated_data/dm_dict.RDS&quot;) dr_dict &lt;- readRDS(&quot;generated_data/dm_eye_disease_dict.RDS&quot;) kidney_disease_case_dict &lt;- readRDS(&quot;generated_data/kidney_disease_case_dict.RDS&quot;) 9.1.1 DM Define T1D and T2D keywords. type2_kw &lt;- &quot;type 2|type II|adult onset|non[ -]insulin[ -]dep|NIDD|maturity onset diabetes mellitus$&quot; type1_kw &lt;- &quot;type 1|type I[ $-]|juvenile|insulin-dependant|insulin dependent&quot; Add diabetes types to DM dictionary. dm_dict &lt;- dm_dict %&gt;% mutate(dm_type = ifelse(grepl(type2_kw,term_description, ignore.case=T), &quot;Type2&quot;, ifelse(grepl(type1_kw, term_description, ignore.case=T), &quot;Type1&quot;, &quot;Uncertain&quot;))) Subset the primary care data to subjects with diabetes and identify which type of diabetes each event is associated with diabetics_any &lt;- pc %&gt;% select(f.eid, code, event_dt) %&gt;% filter(code %in% unique(dm_dict$code)) %&gt;% distinct() %&gt;% left_join(dm_dict %&gt;% select(code,dm_type), by = &quot;code&quot;) Next, we select the terms in the DM-specific dictionary whose descriptions reflect more clear indications of DM. Defined as an object dm_descriptions in reference.R, the descriptions were selected with the help of an expert. dm_codes_confident &lt;- dm_dict %&gt;% filter(term_description %in% dm_descriptions) %&gt;% .$code %&gt;% unique We define this list of terms with clear DM indications to be able to more accurately identify the first diagnosis date diabetes. Specifically, if a subject had terms predating the certain diagnosis which are less certain, we assume that the earlier diagnosis was the better start date. For example, consider a hypothetical subject with following diabetes events: 2012: “Diabetic dietary review” 2013: “Type II diabetes” This individual will be considered type 2 diabetic patient with 2012 as the first date of DM diagnosis. Although the predating description “Diabetic dietary review” is a less certain of diagnosis, a subsequent diagnosis of “Type II diabetes” tells us this subject clearly has Type II diabetes. In contrast, the following subject would not be included as diabetes patient because the codes are not strong enough to indicate diabetes: 2012: “Diabetic dietary review” 2013: “Diabetic dietary review” Based on this procedure, we will generate first occurrence event table for diabetes. First, subset the event table with any indications of diabetes to events with clear indications of diabetes. diabetics_simple &lt;- diabetics_any %&gt;% group_by(f.eid) %&gt;% filter(any(code %in% dm_codes_confident)) %&gt;% mutate(event_dt = as.Date(event_dt)) %&gt;% arrange(f.eid,event_dt) %&gt;% distinct() Generate first occurrence diabetes events. dm_firstoccur_pc &lt;- diabetics_simple %&gt;% group_by(f.eid) %&gt;% arrange(event_dt) %&gt;% slice(1) %&gt;% select(f.eid, event_dt) saveRDS(diabetics_simple,&quot;generated_data/dm_pc.RDS&quot;) saveRDS(dm_firstoccur_pc,&quot;generated_data/dm_firstoccur_pc.RDS&quot;) 9.1.2 DR Phenotype diabetic eye disease event table. dr_pc &lt;- pc %&gt;% filter(code %in% dr_dict$code) %&gt;% select(f.eid,event_dt) %&gt;% mutate(event_dt=as.Date(event_dt)) %&gt;% distinct() %&gt;% arrange(f.eid,event_dt) Generate first occurrence diabetic eye disease event table. dr_firstoccur_pc &lt;- dr_pc %&gt;% group_by(f.eid) %&gt;% arrange(event_dt) %&gt;% slice(1) saveRDS(dr_pc,&quot;generated_data/dr_pc.RDS&quot;) saveRDS(dr_firstoccur_pc,&quot;generated_data/dr_firstoccur_pc.RDS&quot;) 9.1.3 DKD Phenotype diabetic kidney disease event table. kidney_disease_case_pc &lt;- pc %&gt;% filter(code %in% kidney_disease_case_dict$code) %&gt;% select(f.eid,event_dt) %&gt;% mutate(event_dt = as.Date(event_dt)) %&gt;% distinct() %&gt;% arrange(f.eid,event_dt) Generate first occurrence diabetic kidney disease event table. kidney_disease_case_firstoccur_pc &lt;- kidney_disease_case_pc %&gt;% group_by(f.eid) %&gt;% arrange(event_dt) %&gt;% slice(1) saveRDS(kidney_disease_case_pc,&quot;generated_data/kidney_disease_case_pc.RDS&quot;) saveRDS(kidney_disease_case_firstoccur_pc,&quot;generated_data/kidney_disease_case_firstoccur_pc.RDS&quot;) "],["9.2-phenotype-control-exclusion-events-1.html", "9.2 Phenotype control exclusion events", " 9.2 Phenotype control exclusion events Import the outcome-specific dictionaries for control exclusion events. nondm_eye_disease_dict &lt;- readRDS(&quot;generated_data/nondm_eye_disease_dict.RDS&quot;) kidney_disease_control_exclusion_dict &lt;- readRDS(&quot;generated_data/kidney_disease_control_exclusion_dict.RDS&quot;) 9.2.1 Non-diabetic eye disease events Phenotype non-diabetic eye disease event table. nondm_eye_disease_pc &lt;- pc %&gt;% filter(code %in% nondm_eye_disease_dict$code) %&gt;% select(f.eid,event_dt) %&gt;% mutate(event_dt=as.Date(event_dt)) saveRDS(nondm_eye_disease_pc,&quot;generated_data/nondm_eye_disease_pc.RDS&quot;) 9.2.2 Kidney disease control exclusion events Phenotype kidney disease control exclusion event table. kidney_disease_control_exclusion_pc &lt;- pc %&gt;% filter(code %in% kidney_disease_control_exclusion_dict$code) %&gt;% mutate(event_dt = as.Date(event_dt)) saveRDS(kidney_disease_control_exclusion_pc,&quot;generated_data/kidney_disease_control_exclusion_pc.RDS&quot;) "],["10-traj-ukb.html", "10 Create biomarker trajectory data from UK biobank assessment center data", " 10 Create biomarker trajectory data from UK biobank assessment center data In this chapter, we create biomarker trajectory data using the UKB assessment center data. The biomarkers we phenotype are platelet urine albumin urine creatinine blood albumin blood creatinine cholesterol cystatin C blood glucose (random) hba1c HDL LDL triglycerides systolic blood pressure (SBP) diastolic blood pressure (DBP) urine albumin to urine creatinine ratio (UACR) In addition, we phenotype patient’s macroalbumuminuria or microalbuminuria status which will be used in phenotyping time-to-event data for diabetic kidney disease. As we did in chapters 3 and 5, we exclude any subjects who have mismatch between self-reported sex and genetically determined sex. If biomarker measurements or their dates are missing, we exclude those measurements from the trajectory table as well. Load packages and functions. library(tidyverse) library(lubridate) source(&quot;functions.R&quot;) Load reformatted UKB demographics and labs tables. demog_ukb &lt;- readRDS(&quot;generated_data/demog_UKB.RDS&quot;) labs_ukb &lt;- readRDS(&quot;generated_data/labs_UKB.RDS&quot;) demog_sel &lt;- readRDS(&quot;generated_data/demog_selected.RDS&quot;) Define dictionary that maps field ID’s to biomarkers. fieldID_key &lt;- c( &quot;30080&quot; = &quot;platelets&quot;, &quot;30500&quot; = &quot;albumin_urine&quot;, &quot;30510&quot; = &quot;creat_urine&quot;, &quot;30600&quot; = &quot;albumin_blood&quot;, &quot;30690&quot; = &quot;chol&quot;, &quot;30700&quot; = &quot;creat_blood&quot;, &quot;30720&quot; = &quot;cystatin_c&quot;, &quot;30740&quot; = &quot;glucose_rand&quot;, #&quot;Blood glucose&quot; &quot;30750&quot; = &quot;hba1c&quot;, &quot;30760&quot; = &quot;hdl&quot;, &quot;30780&quot; = &quot;ldl&quot;, &quot;30870&quot; = &quot;trig&quot;, &quot;4080&quot; = &quot;sbp&quot;, &quot;93&quot; = &quot;sbp&quot;, &quot;4079&quot; = &quot;dbp&quot;, &quot;94&quot; = &quot;dbp&quot; ) Create biomarker trajectory data for all biomarkers defined above. biomarker_traj_tab_long &lt;- full_join(labs_ukb,demog_ukb) %&gt;% select(f.eid,matches(paste0(paste(paste0(&#39;f.&#39;,names(fieldID_key)),collapse = &#39;|&#39;)))) %&gt;% pivot_longer(cols = -f.eid, names_to = &quot;fields&quot;, values_to = &quot;measurement&quot;) %&gt;% filter(!is.na(measurement)) %&gt;% separate(fields, c(&#39;f&#39;,&quot;biomarker_field_id&quot;, &quot;visit&quot;, &quot;array&quot;), sep = &quot;\\\\.&quot;) %&gt;% mutate(biomarker = fieldID_key[biomarker_field_id]) %&gt;% left_join(demog_sel %&gt;% select(f.eid,date_init,date_repeat)) %&gt;% mutate(event_dt = as.Date(ifelse(visit == &#39;0&#39;, date_init, ifelse(visit==&#39;1&#39;, date_repeat, NA)), origin=origin)) %&gt;% select(f.eid,measurement,event_dt,visit,biomarker) Compute urine albumin to urine creatinine ratio (UACR). uacr_traj &lt;- biomarker_traj_tab_long %&gt;% filter(biomarker %in% c(&quot;albumin_urine&quot;,&quot;creat_urine&quot;)) %&gt;% pivot_wider(id_cols = c(f.eid,event_dt), names_from = c(biomarker,visit), values_from = measurement) %&gt;% mutate(uacr0 = albumin_urine_0/(creat_urine_0*10^-3), uacr1 = albumin_urine_1/(creat_urine_1*10^-3)) %&gt;% select(f.eid,event_dt,uacr0,uacr1) %&gt;% pivot_longer(cols = c(uacr0,uacr1), names_to = &quot;visit&quot;, values_to = &quot;measurement&quot;) %&gt;% mutate(visit = ifelse(visit == &quot;uacr0&quot;,&#39;0&#39;,&#39;1&#39;)) %&gt;% select(f.eid,measurement,event_dt,visit) %&gt;% filter(!is.na(measurement)) %&gt;% mutate(biomarker = &quot;uacr&quot;) Add UACR trajectory data to the biomarker_traj_tab_long. biomarker_traj_tab_long &lt;- bind_rows(biomarker_traj_tab_long,uacr_traj) %&gt;% filter(!is.na(event_dt),!is.na(measurement)) Create macro/microalbuminuria event table. albuminuria_event_tab &lt;- biomarker_traj_tab_long %&gt;% filter(biomarker == &quot;uacr&quot;) %&gt;% mutate(macroalbuminuria = ifelse(measurement &lt; 33.9,F,T), microalbuminuria = ifelse(measurement &lt; 3.4,F,T)) %&gt;% select(f.eid,event_dt,macroalbuminuria,microalbuminuria) %&gt;% pivot_longer(cols=c(macroalbuminuria,microalbuminuria),values_to = &quot;event&quot;, names_to = &quot;type&quot;) %&gt;% select(f.eid,event,event_dt,type) If a subject was missing urine albumin or urine creatinine levels, we cannot compute urine albumin to creatinine ratio (UACR). Urine albumin levels were assumed to be undetectable (NAs) if urine albumin levels were below \\(6.7\\). Subjects with known detection issue had missing urine albumin measurements. However, we can still rule out micro/macroalbuminuria using the urine creatinine levels by computing the upper bound of UACR. To elaborate, suppose a subject’s urine albumin level \\(a\\) is below the detection level, i.e. \\(a &lt; 6.7\\). Then, \\(ACR = \\frac{a}{c \\times 10^{-3}} &lt; \\frac{6.7}{c\\times 10^{-3}}\\) where \\(c:=\\) urine creatinine levels. Thus, \\(\\frac{6.7}{c\\times 10^{-3}}\\) is an upper bound of ACR for the subject. Thus -if the upper bound of \\(ACR\\) is less than 33.9, rule out macroalbuminuria -if the upper bound of \\(ACR\\) is less than 3.4, rule out microalbuminuria. subjects_with_urine_albumin_below_detection_limit &lt;- labs_ukb %&gt;% rename(below_detection_visit0 = f.30505.0.0, below_detection_visit1 = f.30505.1.0) %&gt;% select(f.eid,contains(&quot;below&quot;)) %&gt;% pivot_longer(contains(&quot;below&quot;),names_to = &quot;visit&quot;,values_to = &quot;below_detection_limit&quot;) %&gt;% mutate(visit = ifelse(visit == &quot;below_detection_visit0&quot;,0,1), below_detection_limit = ifelse(is.na(below_detection_limit),NA,T)) %&gt;% filter(below_detection_limit == T) %&gt;% select(f.eid,visit) albuminuria_event_tab_inferred &lt;- biomarker_traj_tab_long %&gt;% filter(biomarker == &quot;creat_urine&quot;) %&gt;% filter(f.eid %in% subjects_with_urine_albumin_below_detection_limit$f.eid) %&gt;% mutate(ACR_upper_bound = 6.7/(measurement*10^-3)) %&gt;% mutate(macroalbuminuria = ifelse(ACR_upper_bound &lt; 33.9,F,NA), microalbuminuria = ifelse(ACR_upper_bound &lt; 3.4,F,NA)) %&gt;% select(f.eid,event_dt,macroalbuminuria,microalbuminuria) %&gt;% pivot_longer(cols=c(macroalbuminuria,microalbuminuria),values_to = &quot;event&quot;, names_to = &quot;type&quot;) %&gt;% filter(!is.na(event)) %&gt;% select(f.eid,event,event_dt,type) Combine inferred albuminuria event table with albuminuria_event_tab albuminuria_event_tab &lt;- bind_rows(albuminuria_event_tab,albuminuria_event_tab_inferred) %&gt;% distinct() Load demographics table and ID’s of subjects with sex mismatch. demog &lt;- readRDS(&quot;generated_data/demog_selected.RDS&quot;) sex_mismatch_subject_ids &lt;- readRDS(&quot;generated_data/sex_mismatch_subject_ids.RDS&quot;) Filter out the following from the biomarker trajectory table and albuminuria event table: any subjects with sex mismatch any unknown measurements any measurements with unknown dates biomarker_traj_tab_long &lt;- biomarker_traj_tab_long[!(biomarker_traj_tab_long$f.eid %in% sex_mismatch_subject_ids),] biomarker_traj_tab_long &lt;- biomarker_traj_tab_long %&gt;% left_join(demog %&gt;% select(f.eid,DOB),by=&quot;f.eid&quot;) biomarker_traj_tab_long$event_dt &lt;- cleandates(biomarker_traj_tab_long$event_dt,biomarker_traj_tab_long$DOB,T) %&gt;% as.Date() biomarker_traj_tab_long &lt;- biomarker_traj_tab_long %&gt;% select(-DOB) biomarker_traj_tab_long &lt;- biomarker_traj_tab_long[!is.na(biomarker_traj_tab_long$event_dt),] biomarker_traj_tab_long &lt;- biomarker_traj_tab_long[!is.na(biomarker_traj_tab_long$measurement),] albuminuria_event_tab &lt;- albuminuria_event_tab[!(albuminuria_event_tab$f.eid %in% sex_mismatch_subject_ids),] albuminuria_event_tab &lt;- albuminuria_event_tab %&gt;% left_join(demog %&gt;% select(f.eid,DOB),by=&quot;f.eid&quot;) albuminuria_event_tab$event_dt &lt;- cleandates(albuminuria_event_tab$event_dt,albuminuria_event_tab$DOB,T) %&gt;% as.Date() albuminuria_event_tab &lt;- albuminuria_event_tab %&gt;% select(-DOB) albuminuria_event_tab &lt;- albuminuria_event_tab[!is.na(albuminuria_event_tab$event_dt),] Save the biomarker trajectory table and albuminuria event table extracted from the UKB asssessment center data. saveRDS(biomarker_traj_tab_long,&quot;generated_data/biomarker_trajectory_ukb.RDS&quot;) saveRDS(albuminuria_event_tab,&quot;generated_data/albuminuria_event_tab_ukb.RDS&quot;) "],["11-traj-pcp.html", "11 Create biomarker trajectory data from primary care data", " 11 Create biomarker trajectory data from primary care data In this chapter, we create biomarker trajectory data using the primary care data. The biomarkers we phenotype are urine albumin urine creatinine blood creatinine blood glucose (random) fasting glucose hba1c HDL LDL triglycerides systolic blood pressure (SBP) diastolic blood pressure (DBP) urine albumin to urine creatinine ratio (UACR) BMI As we did in the previous chapter, we phenotype patient’s macroalbumuminuria or microalbuminuria status, and exclude events whose measurements or their dates are missing. However, we do not apply sex mismatch filters since we have already filtered out those subjects in chapter 5. Load necessary packages. library(tidyverse) library(knitr) Load reformatted primary care table. gp_clinical &lt;- data.table::fread(&quot;generated_data/entire_gp_clinical_30March2021_formatted.txt&quot;) head(gp_clinical) Read in the previously generated full code dictionary for primary care terms. full_dict &lt;- readRDS(&quot;generated_data/full_dict.RDS&quot;) tail(full_dict) For the purpose of combining the dictionary with gp_clinical, remove terms with missing descriptions, additional descriptions for the same code, and identical codes+descriptions across terminology(read v2/CTV3). full_dict &lt;- full_dict %&gt;% select(-terminology) %&gt;% distinct() %&gt;% filter(term_description != &quot;&quot;) %&gt;% distinct(code, .keep_all = T) tail(full_dict) Add the term descriptions to gp_clinical. gp_clinical &lt;- gp_clinical %&gt;% left_join(full_dict) Define the clinical terms to extract from gp_clinical for each biomarker. Each biomarker gets a string to be used in a grepl pattern matching query, and as such different patterns should be separated by ‘|’, brackets used to denote multiple possible patterns to match, and ‘^’ to denote the beginning of the string. BP_codes &lt;- &quot;^246[.cdgABCDEFGJNPQRSTVWXY012345679]|^XaF4[abFLOS]|^XaJ2[EFGH]|^XaKF[xw]|^G20&quot; HDL_codes &lt;- &#39;^44d[23]|^X772M|^44P[5BC]|^XaEVr&#39; LDL_codes &lt;- &#39;^44d[45]|^44P[6DE]|^XaEVs&#39; totchol_codes &lt;- &quot;^44P[.12349HJKZ]|^XE2eD|^XSK14|^XaFs9|^XaIRd|^XaJe9|^XaLux&quot; triglyc_codes &lt;- &#39;^44e|^44Q|^X772O|^XE2q9&#39; fastgluc_codes &lt;- &quot;^44[fg]1&quot; randgluc_codes &lt;- &quot;^44[fg][0\\\\.]|^44TA|^XM0ly&quot; a1c_codes &lt;- &quot;^XaPbt|^XaERp|^X772q|^42W[12345Z\\\\.]\\\\.|^44TB\\\\.&quot; height_weight_BMI_codes &lt;- &quot;^XaCDR|^XaJJH|^XaJqk|^XaZcl|^22K|^229|^22A|^162[23]|^X76CG|^XE1h4|^XM01G|^Xa7wI&quot; blood_creatinine_codes &lt;- &#39;^44J3[.0123z]|^44J[CDF]|XE2q5|XaERc|XaERX|XaETQ|^4Q40.|X771Q&#39; urine_creatinine_codes &lt;- &#39;^46M7&#39; urine_albumin_codes &lt;- &#39;^46N4|^XE2eI|^46N8.|^46W[\\\\.01]|^XE2bw&#39; UACR_codes &lt;- &#39;^46TC|^XE2n3|^X773Y|^46TD|^XE2n4&#39; "],["11.1-total-cholesterol.html", "11.1 Total cholesterol", " 11.1 Total cholesterol UK Biobank measurements range from 0.601 to 15.46 mmol/L. We filter the allowable range to lie between 0.5 and 30. totchol &lt;- gp_clinical %&gt;% filter(grepl(totchol_codes, code)) %&gt;% mutate(totchol = coalesce(as.numeric(value1), as.numeric(value2), as.numeric(value3))) %&gt;% filter(totchol &gt; 0.5 &amp; totchol &lt; 30) %&gt;% filter(!(value3 %in% c(&quot;MEA001&quot;, &quot;mg/mmol&quot;, &quot;%&quot;, &quot;MEA090&quot;, &quot;MEA093&quot;, &quot;MEA099&quot;, &quot;MEA110&quot;, &quot;MEA142&quot;, &quot;MEA156&quot;, &quot;mmo&quot;, &quot;mmol&quot;, &quot;mmol/d&quot;, &quot;mOsm/kg&quot;, &quot;mPa/s&quot;, &quot;nmol/l&quot;, &quot;U/mL&quot;, &quot;umol/L&quot;))) totchol %&gt;% group_by(code, term_description) %&gt;% summarize(n=n(), mean = mean(totchol, na.rm=T)) %&gt;% arrange(desc(n)) %&gt;% kable() ggplot(data=totchol, aes(x=log10(totchol))) + geom_density() + theme_minimal() "],["11.2-hdl.html", "11.2 HDL", " 11.2 HDL UK Biobank measurements range from 0.219 to 4.401 mmol/L. We filter the allowable range to be under 10, but not 0. HDL &lt;- gp_clinical %&gt;% filter(grepl(HDL_codes, code)) %&gt;% mutate(HDL = coalesce(as.numeric(value1), as.numeric(value2), as.numeric(value3))) %&gt;% filter(HDL &gt; 0 &amp; HDL &lt; 10) %&gt;% filter(!(value3 %in% c(&quot;09&quot;, &quot;MEA082&quot;, &quot;MEA095&quot;, &quot;MEA099&quot;, &quot;MEA104&quot;, &quot;MEA151&quot;, &quot;mmol&quot;, &quot;mOsm/kg&quot;, &quot;mg/mmol&quot;))) HDL %&gt;% group_by(code, term_description) %&gt;% summarize(n=n(), mean = mean(HDL, na.rm=T)) %&gt;% arrange(desc(n)) %&gt;% kable() ggplot(data=HDL, aes(x=log10(HDL))) + geom_density() + theme_minimal() "],["11.3-ldl.html", "11.3 LDL", " 11.3 LDL UK Biobank measurements range from 0.226 to 9.797 mmol/L. We filter the allowable range to be under 30, but not 0. LDL &lt;- gp_clinical %&gt;% filter(grepl(LDL_codes, code)) %&gt;% mutate(LDL = coalesce(as.numeric(value1), as.numeric(value2), as.numeric(value3))) %&gt;% filter(LDL &gt; 0 &amp; LDL &lt; 30) %&gt;% filter(!(value3 %in% c(&quot;MEA142&quot;, &quot;MEA151&quot;))) LDL %&gt;% group_by(code, term_description) %&gt;% summarize(n=n(), mean = mean(LDL, na.rm=T)) %&gt;% arrange(desc(n)) %&gt;% kable() ggplot(data=LDL, aes(x=log10(LDL))) + geom_density() + theme_minimal() "],["11.4-triglycerides.html", "11.4 Triglycerides", " 11.4 Triglycerides UK Biobank measurements range from 0.231 to 11.278 mmol/L. We filter the allowable range to be under 30, but not 0. triglycerides &lt;- gp_clinical %&gt;% filter(grepl(triglyc_codes, code)) %&gt;% mutate(triglyc = coalesce(as.numeric(value1), as.numeric(value2), as.numeric(value3))) %&gt;% filter(triglyc &gt; 0 &amp; triglyc &lt; 30) %&gt;% filter(!(value3 %in% c(&quot;g&quot;, &quot;g/l&quot;, &quot;MEA099&quot;, &quot;MEA156&quot;))) triglycerides %&gt;% group_by(code, term_description) %&gt;% summarize(n=n(), mean= mean(triglyc, na.rm=T)) %&gt;% arrange(desc(n)) %&gt;% kable() ggplot(data=triglycerides, aes(x=log10(triglyc))) + geom_density() + theme_minimal() "],["11.5-fasting-glucose.html", "11.5 Fasting Glucose", " 11.5 Fasting Glucose UK Biobank measurements for glucose range from 0.995 to 36.813 mmol/L. We filter the allowable range of fasting glucose to be under 60, but not 0. fastgluc &lt;- gp_clinical %&gt;% filter(grepl(fastgluc_codes, code)) %&gt;% mutate(fastgluc = coalesce(as.numeric(value1), as.numeric(value2), as.numeric(value3))) %&gt;% filter(fastgluc &gt; 0 &amp; fastgluc &lt; 60) %&gt;% filter(value3 %in% c(&quot;&quot;, &quot;MEA000&quot;, &quot;MEA061&quot;, &quot;MEA096&quot;, &quot;MEA194&quot;, &quot;Mmol/L&quot;, &quot;Unknown&quot;, &quot;mmol/L&quot;, &quot;mmol/l&quot;, &quot;mU/l&quot;, &quot;units&quot;)) fastgluc %&gt;% group_by(code, term_description) %&gt;% summarize(n=n(), mean = mean(fastgluc, na.rm=T)) %&gt;% arrange(desc(n)) %&gt;% kable() ggplot(data=fastgluc, aes(x=log10(fastgluc))) + geom_density() + theme_minimal() "],["11.6-random-glucose.html", "11.6 Random glucose", " 11.6 Random glucose UK Biobank measurements for glucose range from 0.995 to 36.813 mmol/L. We filter the allowable range of fasting glucose to be under 60, but not 0. randgluc &lt;- gp_clinical %&gt;% filter(grepl(randgluc_codes, code)) %&gt;% mutate(randgluc = coalesce(as.numeric(value1), as.numeric(value2), as.numeric(value3))) %&gt;% filter(randgluc &gt; 0 &amp; randgluc &lt; 60) %&gt;% filter(value3 %in% c(&quot;&quot;, &quot;MEA000&quot;, &quot;MEA061&quot;, &quot;MEA096&quot;, &quot;MEA194&quot;, &quot;Mmol/L&quot;, &quot;Unknown&quot;, &quot;mmol/L&quot;, &quot;mmol/l&quot;, &quot;mU/l&quot;, &quot;units&quot;)) randgluc %&gt;% group_by(code, term_description) %&gt;% summarize(n=n(), mean = mean(randgluc, na.rm=T)) %&gt;% arrange(desc(n)) %&gt;% kable() ggplot(data = randgluc, aes(x=log10(randgluc))) + geom_density() + theme_minimal() "],["11.7-urine-albumin.html", "11.7 Urine Albumin", " 11.7 Urine Albumin UK Biobank measurements for microalbumin in urine have a maximum value of 6746.5 mg/L, with many values below the measurement instrument’s lower limit of detection of 6.7 mg/L. We filter the allowable range to be under 7,000, but not 0. #Extract urine albumin ualb &lt;- gp_clinical %&gt;% filter(grepl(urine_albumin_codes, code, ignore.case=T)) %&gt;% mutate(micro=grepl(&quot;micro&quot;, term_description, ignore.case=T)) %&gt;% mutate(value = coalesce(as.numeric(value1), as.numeric(value2), as.numeric(value3))) %&gt;% filter(!is.na(value) &amp; value != 0) %&gt;% #&amp; value &lt; 500 filter(!(value3 %in% c(&quot;0.3&quot;, &quot;MEA001&quot;, &quot;mg/mmol&quot;, &quot;ml/min&quot;, &quot;mmol/L&quot;, &quot;MEA086&quot;, &quot;MEA096&quot;, &quot;MEA120&quot;, &quot;MEA142&quot;, &quot;MEA166&quot;, &quot;g/L&quot;, &quot;MEA057&quot;))) %&gt;% filter(value &lt; 7000) %&gt;% select(-value1, -value2) %&gt;% dplyr::rename(code_ualb = code, term_description_ualb = term_description, ualb_mg_L = value) %&gt;% distinct() ualb %&gt;% group_by(code_ualb, term_description_ualb) %&gt;% summarize(n=n(), mean = mean(ualb_mg_L)) %&gt;% arrange(desc(n)) %&gt;% kable() Based on the distributions, albumin values are given in mg/L, regardless of whether the term description says microalbumin or albumin. ggplot(data=ualb, aes(x=log10(ualb_mg_L), color = term_description_ualb)) + geom_density() "],["11.8-urine-creatinine.html", "11.8 Urine creatinine", " 11.8 Urine creatinine UK Biobank measurements range from 88 to 88,160 micromoles/L. We filter the allowable range to be below 88,000, but not 0. ucreat &lt;- gp_clinical %&gt;% filter(grepl(urine_creatinine_codes, code, ignore.case=T)) %&gt;% mutate(value = coalesce(as.numeric(value1), as.numeric(value2), as.numeric(value3))) %&gt;% filter(!is.na(value) &amp; value != 0) %&gt;% mutate(ucreat_umol_L = value * 1000) %&gt;% filter(value3 != &quot;MEA099&quot; &amp; value3 != &quot;umol/l&quot;) %&gt;% filter(ucreat_umol_L &lt; 88000) %&gt;% select(-value, -value1, -value2, -value3) %&gt;% dplyr::rename(code_ucreat = code, term_description_ucreat = term_description) %&gt;% distinct() ucreat %&gt;% group_by(code_ucreat, term_description_ucreat) %&gt;% summarize(n=n(), mean = mean(ucreat_umol_L)) %&gt;% kable() ggplot(data=ucreat, aes(x=log10(log10(ucreat_umol_L)))) + geom_density() + theme_minimal() "],["11.9-urine-acr-albumincreatinine-ratio.html", "11.9 Urine ACR (Albumin:Creatinine Ratio)", " 11.9 Urine ACR (Albumin:Creatinine Ratio) This ratio will be needed to define micro/macroalbuminuria phenotypes. The calculated UACR values in UK Biobank lie between 0.15 and 2141.17. For UACR calculated from primary care albumin and creatinine, we only filter based on the original albumin and creatinine measurements. For primary care records of UACR, we filter the value to be below 1000, but not 0. #Manually generate the UACRs from urine creatinine and albumin. ratio_manual &lt;- ualb %&gt;% inner_join(ucreat) %&gt;% mutate(UACR = ualb_mg_L/ucreat_umol_L *1000, manual=T) #Extract UACR from primary care that is already calculated ratio &lt;- gp_clinical %&gt;% filter(grepl(UACR_codes, code, ignore.case=T)) %&gt;% mutate(UACR = coalesce(as.numeric(value1), as.numeric(value2), as.numeric(value3)), micro = grepl(&quot;micro&quot;, term_description), manual = F) %&gt;% filter(!is.na(UACR) &amp; UACR != 0 &amp; UACR &lt; 1000) %&gt;% filter(!(value3 %in% c(&quot;%&quot;, &quot;MEA001&quot;, &quot;MEA083&quot;, &quot;MEA096&quot;, &quot;MEA156&quot;, &quot;MEA169&quot;, &quot;MEA241&quot;, &quot;ml/min&quot;, &quot;mg/L&quot;, &quot;m1/min&quot;, &quot;mmol/L&quot;, &quot;ng/mL&quot;,&quot;umol/L&quot;, &quot;mg/l&quot;))) %&gt;% select(-value1, -value2, -value3) %&gt;% distinct() %&gt;% dplyr::rename(code_uacr = code, term_description_uacr = term_description) #Combine the manually-calculated and already-calculated values of UACR UACR &lt;- full_join(ratio, ratio_manual) %&gt;% distinct(f.eid, event_dt, .keep_all = T) UACR %&gt;% group_by(manual, term_description_uacr, term_description_ualb) %&gt;% summarize(n=n(), mean = mean(UACR, na.rm=T)) %&gt;% arrange(desc(n)) %&gt;% kable() ggplot(data=UACR, aes(x=log10(UACR))) + geom_density() + theme_minimal() "],["11.10-bloodserum-creatinine.html", "11.10 Blood/Serum creatinine", " 11.10 Blood/Serum creatinine This is needed to calculate eGFR. UK Biobank measures lie between 10.7 and 1499.3. We filter the allowable range to lie between 10 and 1500. blood_creatinine &lt;- gp_clinical %&gt;% filter(grepl(blood_creatinine_codes, code)) %&gt;% mutate(blood_creatinine = coalesce(as.numeric(value1), as.numeric(value2))) %&gt;% filter(blood_creatinine &gt; 10 &amp; blood_creatinine &lt; 1500) %&gt;% filter(!(value3 %in% c(&quot;m1/min&quot;, &quot;MEA082&quot;, &quot;MEA083&quot;, &quot;MEA095&quot;, &quot;MEA096&quot;, &quot;mg/mmol&quot;, &quot;ml/min&quot;, &quot;mmol&quot;, &quot;mmol/l&quot;, &quot;mmol/L&quot;, &quot;nmol/l&quot;, &quot;pmol/l&quot;, &quot;uL/cu mm&quot;, &quot;um&quot;, &quot;umo&quot;, &quot;umol&quot;))) %&gt;% mutate(creatinine_type = ifelse(grepl(&quot;serum&quot;, term_description, ignore.case=T), &quot;Serum&quot;, ifelse(grepl(&quot;plasma&quot;, term_description, ignore.case=T), &quot;Plasma&quot;, &quot;Unspecified&quot;))) blood_creatinine %&gt;% group_by(code, term_description) %&gt;% summarize(n=n(), mean=mean(blood_creatinine)) %&gt;% arrange(desc(n)) %&gt;% kable() ggplot(data=blood_creatinine, aes(x=blood_creatinine, color=creatinine_type)) + geom_density() + theme_minimal() "],["11.11-hba1c.html", "11.11 HbA1c", " 11.11 HbA1c Calculate HbA1c in both % (US) and mmol/mol (UK). UK Biobank measurements lie between 15 and 515.2 mmol/mol. In primary care data, some values are given in percent, some in mmol/mol. We filter the allowable range to lie between 4 and 18 (%) or between 20.2 and 173.2 (mmol/mol) to guard against including values recorded under the incorrect unit. Conversion between % and mmol/mol is performed using the IFCC-NGSP master equation (https://doi.org/10.1373/clinchem.2008.103556). a1c &lt;- gp_clinical %&gt;% filter(grepl(a1c_codes, code)) %&gt;% mutate(hba1c = coalesce(as.numeric(value1), as.numeric(value2), as.numeric(value3))) %&gt;% filter(hba1c &gt; 0) %&gt;% mutate(value3 = toupper(value3)) %&gt;% mutate(value3 = ifelse(value3 %in% c(&quot;MEA000&quot;, &quot;MMOL/M&quot;, &quot;MEA097&quot;, &quot;UNKNOWN&quot;, &quot;MEA001&quot;, &quot;%&quot;, &quot;HBA1C&quot;, &quot;%TOTAL HB&quot;, &quot;% TOTAL HB&quot;, &quot;MEA215&quot;, &quot;MMOL/MOL HB&quot;, &quot;PER CENT&quot;, &quot;%TOTAL&quot;), &quot;&quot;, value3)) %&gt;% mutate(units = ifelse(value3 != &quot;&quot;, value3, ifelse(code %in% c(&quot;XaPbt&quot;, &quot;42W5.&quot;), &quot;MMOL/MOL&quot;, &quot;%&quot;))) %&gt;% filter(units %in% c(&quot;%&quot;, &quot;MMOL/MOL&quot;)) %&gt;% mutate(hba1c_percent = ifelse(units == &quot;%&quot;, round(hba1c, 1), round(hba1c/10.929 + 2.15, 1))) %&gt;% mutate(hba1c_mmol_mol = ifelse(units ==&quot;%&quot;, round(10.929 * (hba1c - 2.15), 1), round(hba1c, 1))) %&gt;% filter(hba1c_percent &gt; 4 &amp; hba1c_percent &lt; 18) %&gt;% dplyr::rename(original_unit = units) a1c %&gt;% group_by(code, term_description) %&gt;% summarize(n=n(), mean=mean(hba1c_percent, na.rm=T)) %&gt;% arrange(desc(n)) %&gt;% kable() ggplot(data=a1c, aes(x = hba1c_percent, color = original_unit)) + geom_density() "],["11.12-bmi.html", "11.12 BMI", " 11.12 BMI Height may be measured using meters or centimeters. Height was filtered to lie between 1.25m (4ft 1.2 inches) and 2.1m (6ft 10.7 inches). Values between 125 and 210 were assumed to be in cm and so were divided by 100. Weight is measured in kg and was filtered to lie between 30kg(66.1 lb) and 200kg(440.9 lb). BMI was filtered to lie between 12 and 75 kg/m^2. #Extract height, weight, and BMI hwbmi &lt;- gp_clinical %&gt;% filter(grepl(height_weight_BMI_codes, code)) %&gt;% mutate(value = coalesce(as.numeric(value1), as.numeric(value2), as.numeric(value3))) %&gt;% filter(!is.na(value) &amp; value &gt; 0) %&gt;% mutate(trait = ifelse(grepl(&quot;BMI|Body Mass Index&quot;, term_description, ignore.case=T), &quot;BMI&quot;, ifelse(grepl(&quot;Height&quot;, term_description, ignore.case=T), &quot;Height&quot;, &quot;Weight&quot;))) %&gt;% mutate(value = ifelse(trait == &quot;Height&quot; &amp; value &gt; 2.1, value/100, value)) %&gt;% #cm to meters filter((trait == &quot;Weight&quot; &amp; value &lt; 200 &amp; value &gt; 30) | (trait == &quot;Height&quot; &amp; value &lt; 2.1 &amp; value &gt; 1.25 )| (trait == &quot;BMI&quot; &amp; value &lt; 75 &amp; value &gt; 12)) %&gt;% arrange(f.eid, event_dt) #Here are the resulting terms: hwbmi %&gt;% group_by(code, term_description, trait) %&gt;% summarize(n = n(), mean=round(mean(value), 1)) %&gt;% arrange(trait, desc(n)) %&gt;% kable() #Separate the traits weight &lt;- hwbmi %&gt;% filter(trait == &quot;Weight&quot;) height &lt;- hwbmi %&gt;% filter(trait == &quot;Height&quot;) BMI &lt;- hwbmi %&gt;% filter(trait == &quot;BMI&quot;) #Some records from data provider 2 give weight and BMI bmi_extra &lt;- weight %&gt;% filter(data_provider == 2) %&gt;% mutate(bmi_extra = as.numeric(value3)) %&gt;% filter(!is.na(bmi_extra)) %&gt;% filter(bmi_extra &gt; 12) head(bmi_extra) #combine the traits in wider format weight_pre &lt;- weight %&gt;% select(-c(terminology, value1, value2, value3, trait)) %&gt;% dplyr::rename(weight = value, weight_code = code, weight_term_description = term_description) height_pre &lt;- height %&gt;% select(-c(terminology, value1, value2, value3, trait)) %&gt;% dplyr::rename(height = value, height_code = code, height_term_description = term_description) BMI_pre &lt;- BMI %&gt;% select(-c(terminology, value1, value2, value3, trait)) %&gt;% dplyr::rename(BMI = value, BMI_code = code, BMI_term_description = term_description) bmi_extra_pre &lt;- bmi_extra %&gt;% select(-c(terminology, term_description, value1, value2, value3, trait, value)) %&gt;% dplyr::rename(bmi_extra_code = code) joined_bmi &lt;- full_join(weight_pre, height_pre) %&gt;% full_join(BMI_pre) %&gt;% full_join(bmi_extra_pre) head(joined_bmi) Clean the combined data, filling in missing height values from previous/subsequent measurements or BMI. Filter out cases where the calculated and reported BMI differ by more than 1.5. cleaned_bmi &lt;- joined_bmi %&gt;% group_by(f.eid) %&gt;% fill(height, .direction = &quot;downup&quot;) %&gt;% mutate(BMI_coalesce = round(coalesce(BMI, bmi_extra), 1), BMI_calculated = round(weight/(height^2), 1), BMI_mismatch = BMI_coalesce != BMI_calculated, BMI_diff = BMI_coalesce - BMI_calculated) %&gt;% filter(!(!is.na(BMI_diff) &amp; abs(BMI_diff) &gt; 1.5)) %&gt;% mutate(BMI_final = coalesce(BMI_calculated, BMI_coalesce)) %&gt;% mutate(height = ifelse(!is.na(height), height, sqrt(weight/BMI))) %&gt;% dplyr::rename(BMI_reported = BMI_coalesce, height_carried = height) %&gt;% filter(height_carried &lt; 2.1 &amp; height_carried &gt; 1.25 &amp; BMI_final &lt; 75 &amp; BMI_final &gt; 12) %&gt;% select(f.eid, data_provider, event_dt, weight, height_carried, BMI_reported, BMI_calculated, BMI = BMI_final) %&gt;% distinct() %&gt;% mutate(source=&quot;PC&quot;) ggplot(data=cleaned_bmi, aes(x=log10(BMI))) + geom_density() + theme_minimal() "],["11.13-blood-pressure.html", "11.13 Blood Pressure", " 11.13 Blood Pressure To to extract blood pressure, it is necessary to consider both the cases where both Systolic and Diastolic BP are provided in the same record, as well as cases where Systolic and Diastolic BP are given in separate records. bp &lt;- gp_clinical %&gt;% filter(grepl(BP_codes, code)) %&gt;% filter(value1 != &quot;&quot; | value2 != &quot;&quot; | value3 != &quot;&quot;) %&gt;% mutate(value1 = as.numeric(value1), value2 = as.numeric(value2), value3 = as.numeric(value3)) #Remove some small values in value3 of unknown meaning bp$value3[bp$value3 &lt; 10] &lt;- NA #Separate the data into two types of record: One where 2 values are given in 1 record (e.g. Systolic and Diastolic) and another where there is only one value (i.e Systolic only or Diastolic only) given per record. Multiple values per record: Take the larger value to be systolic and the smaller value to be diastolic. Filter out any records where either of these values are 0. bp_mult &lt;- bp %&gt;% rowwise() %&gt;% filter(sum(!is.na(value1), !is.na(value2), !is.na(value3)) == 2) %&gt;% ungroup() %&gt;% mutate(Systolic_bp_pc = pmax(value1, value2, value3, na.rm=T)) %&gt;% mutate(Diastolic_bp_pc = pmin(value1, value2, value3, na.rm=T)) %&gt;% filter(Systolic_bp_pc != 0 &amp; Diastolic_bp_pc != 0) One value per record: filter out those with a value of 0. bp_single &lt;- bp %&gt;% rowwise() %&gt;% filter(sum(!is.na(value1), !is.na(value2), !is.na(value3)) == 1) %&gt;% ungroup() %&gt;% mutate(value = coalesce(value1, value2, value3)) %&gt;% filter(value != 0) %&gt;% arrange(f.eid, event_dt) %&gt;% mutate(bp_type = ifelse(grepl(&quot;systolic&quot;, term_description, ignore.case=T), &quot;Systolic_bp_pc&quot;, ifelse(grepl(&quot;diastolic&quot;, term_description, ignore.case = T), &quot;Diastolic_bp_pc&quot;, &quot;Unknown&quot;))) %&gt;% select(-value1, -value2, -value3) %&gt;% distinct() #Here are the results for single type: bp_single %&gt;% group_by(code, term_description, bp_type) %&gt;% summarize(n=n(), mean=round(mean(value, 1))) %&gt;% arrange(bp_type, desc(n)) Look at the remaining codes to see if they are systolic or diastolic. For many of these, the same code is given twice, each with a different value. Sometimes an record is a duplicate of a systolic or diastolic measurement. If there are two unique values given per ID/date, then we can assume they are systolic (higher) and diastolic (lower). Otherwise, discard that set of values. #Unknowns - not specified as Diastolic vs. Systolic unknowns &lt;- bp_single %&gt;% group_by(f.eid, event_dt) %&gt;% filter(sum(bp_type == &quot;Unknown&quot;) &gt; 0) %&gt;% mutate(n = length(unique(value))) %&gt;% filter(n == 2) %&gt;% mutate(Systolic_bp_pc = max(value)) %&gt;% mutate(Diastolic_bp_pc = min(value)) %&gt;% distinct(f.eid, event_dt, value, .keep_all = T) %&gt;% group_by(f.eid, event_dt) %&gt;% mutate(code_systolic = code[which(value == max(value))], code_diastolic = code[which(value == min(value))], term_description_systolic = term_description[which(value == max(value))], term_description_diastolic = term_description[which(value == min(value))]) #Prepare for merging bp_single_less &lt;- bp_single %&gt;% distinct(f.eid, data_provider, event_dt, value, bp_type, .keep_all = T) %&gt;% group_by(f.eid, event_dt) %&gt;% filter(sum(bp_type == &quot;Systolic_bp_pc&quot;) == 1 &amp; sum(bp_type == &quot;Diastolic_bp_pc&quot;) == 1) %&gt;% filter(bp_type != &quot;Unknown&quot;) systolic &lt;- bp_single_less %&gt;% filter(bp_type == &quot;Systolic_bp_pc&quot;) %&gt;% dplyr::rename(code_systolic = code, Systolic_bp_pc = value, term_description_systolic = term_description) %&gt;% select(-bp_type) diastolic &lt;- bp_single_less %&gt;% filter(bp_type == &quot;Diastolic_bp_pc&quot;) %&gt;% dplyr::rename(code_diastolic = code, Diastolic_bp_pc = value, term_description_diastolic = term_description) %&gt;% select(-bp_type) bp_single_wide &lt;- full_join(systolic, diastolic) head(bp_single_wide) Combine each of the cleaned subsets and implement some common sense filters (45 &lt; Systolic bp &lt; 300, 30 &lt; Diastolic bp &lt; Systolic bp). unknowns_less &lt;- unknowns %&gt;% select(-term_description, -value, -bp_type, -code, -n) %&gt;% distinct() bp_mult_less &lt;- bp_mult %&gt;% dplyr::rename(term_description_both = term_description) %&gt;% dplyr::rename(code_both = code) %&gt;% select(f.eid, event_dt, data_provider, terminology, Systolic_bp_pc, Diastolic_bp_pc, code_both, term_description_both) %&gt;% distinct() full_bp_clean &lt;- full_join(unknowns_less, bp_single_wide) %&gt;% full_join(bp_mult_less) %&gt;% filter(Systolic_bp_pc &gt; Diastolic_bp_pc) %&gt;% filter(Systolic_bp_pc &gt;= 45 &amp; Systolic_bp_pc &lt;= 300) %&gt;% filter(Diastolic_bp_pc &gt;= 30) %&gt;% distinct(f.eid, event_dt, Systolic_bp_pc, Diastolic_bp_pc, .keep_all=T) head(full_bp_clean) ggplot(data=full_bp_clean, aes(x=log10(Systolic_bp_pc))) + geom_density() + theme_minimal() ggplot(data=full_bp_clean, aes(x=log10(Diastolic_bp_pc))) + geom_density() + theme_minimal() "],["11.14-reformat-and-trim-trajectory-table-for-each-biomarker.html", "11.14 Reformat and trim trajectory table for each biomarker", " 11.14 Reformat and trim trajectory table for each biomarker sbp &lt;- full_bp_clean %&gt;% select(f.eid,Systolic_bp_pc,event_dt) %&gt;% rename(measurement = Systolic_bp_pc) %&gt;% mutate(biomarker = &quot;sbp&quot;) dbp &lt;- full_bp_clean %&gt;% select(f.eid,Diastolic_bp_pc,event_dt) %&gt;% rename(measurement = Diastolic_bp_pc) %&gt;% mutate(biomarker = &quot;dbp&quot;) cholesterol &lt;- totchol %&gt;% select(f.eid,totchol,event_dt) %&gt;% rename(measurement = totchol) %&gt;% mutate(biomarker = &quot;chol&quot;) hdl &lt;- HDL %&gt;% select(f.eid,HDL,event_dt) %&gt;% rename(measurement = HDL) %&gt;% mutate(biomarker = &quot;hdl&quot;) ldl &lt;- LDL %&gt;% select(f.eid,LDL,event_dt) %&gt;% rename(measurement = LDL) %&gt;% mutate(biomarker = &quot;ldl&quot;) trigly &lt;- triglycerides %&gt;% select(f.eid,triglyc,event_dt) %&gt;% rename(measurement = triglyc) %&gt;% mutate(biomarker = &quot;trig&quot;) glu_fast &lt;- fastgluc %&gt;% select(f.eid,fastgluc,event_dt) %&gt;% rename(measurement = fastgluc) %&gt;% mutate(biomarker = &quot;glucose_fast&quot;) glu_rand &lt;- randgluc %&gt;% select(f.eid,randgluc,event_dt) %&gt;% rename(measurement = randgluc) %&gt;% mutate(biomarker = &quot;glucose_rand&quot;) hba1c &lt;- a1c %&gt;% select(f.eid,hba1c_mmol_mol,event_dt) %&gt;% rename(measurement = hba1c_mmol_mol) %&gt;% mutate(biomarker = &quot;hba1c&quot;) bmi &lt;- cleaned_bmi %&gt;% select(f.eid,BMI,event_dt) %&gt;% rename(measurement = BMI) %&gt;% mutate(biomarker = &quot;bmi&quot;) blood_creat &lt;- blood_creatinine %&gt;% select(f.eid,blood_creatinine,event_dt) %&gt;% rename(measurement = blood_creatinine) %&gt;% mutate(biomarker = &quot;creat_blood&quot;) urine_creat &lt;- ucreat %&gt;% select(f.eid, ucreat_umol_L, event_dt) %&gt;% rename(measurement = ucreat_umol_L) %&gt;% mutate(biomarker = &quot;creat_urine&quot;) urine_albumin &lt;- ualb %&gt;% select(f.eid, ualb_mg_L, event_dt) %&gt;% rename(measurement = ualb_mg_L) %&gt;% mutate(biomarker = &quot;albumin_urine&quot;) uacr &lt;- UACR %&gt;% select(f.eid,UACR,event_dt) %&gt;% rename(measurement = UACR) %&gt;% mutate(biomarker = &quot;uacr&quot;) Combine all of biomarker trajectory datasets into a long format. biomarker_traj_tab_long &lt;- bind_rows(list(sbp,dbp,cholesterol,hdl,ldl,trigly, glu_fast,glu_rand,hba1c,bmi,blood_creat, urine_creat,urine_albumin,uacr)) Create macro/microalbuminuria event table. albuminuria_event_tab &lt;- biomarker_traj_tab_long %&gt;% filter(biomarker == &quot;uacr&quot;) %&gt;% mutate(macroalbuminuria = ifelse(measurement &lt; 33.9,F,T), microalbuminuria = ifelse(measurement &lt; 3.4,F,T)) %&gt;% select(f.eid,event_dt,macroalbuminuria,microalbuminuria) %&gt;% pivot_longer(cols=c(macroalbuminuria,microalbuminuria),values_to = &quot;event&quot;, names_to = &quot;type&quot;) %&gt;% select(f.eid,event,event_dt,type) Filter out the following from the biomarker trajectory table and albuminuria event table: any unknown measurements any measurements with unknown dates biomarker_traj_tab_long &lt;- biomarker_traj_tab_long[!is.na(biomarker_traj_tab_long$event_dt),] biomarker_traj_tab_long &lt;- biomarker_traj_tab_long[!is.na(biomarker_traj_tab_long$measurement),] albuminuria_event_tab &lt;- albuminuria_event_tab[!is.na(albuminuria_event_tab$event_dt),] Save the biomarker trajectory data and albuminuria event table extracted from the primary care data. saveRDS(biomarker_traj_tab_long,&quot;generated_data/biomarker_trajectory_pcp.RDS&quot;) saveRDS(albuminuria_event_tab,&quot;generated_data/albuminuria_event_tab_pcp.RDS&quot;) "],["12-traj-combine.html", "12 Combine biomarker trajectory extracted from from UKB and PCP data", " 12 Combine biomarker trajectory extracted from from UKB and PCP data In the previous chapters 10 and 11, we have created trajectory data for various biomarkers along with macroalbumuminuria or microalbuminuria status. In this chapter, we combine these data to produce the master trajectory data, first occurrence microalbmuinuria event table and first occurrence macroalbuminuria event table. Furthermore, using blood creatinine trajectory data, we phenotype egfr trajectory data which will be used to create prolonged low egfr first occurrence table. The first occurrence macroalbuminuria event table and prolonged low egfr first occurrence table will be used to additionally capture diabetic kidney disease cases, and the first occurrence microalbuminuria event table will be used to phenotype time-to-event data for DKD in chapter 16. Load packages and functions. library(tidyverse) source(&quot;functions.R&quot;) Load UKB and PCP biomarker trajectory data. biomarker_traj_pcp &lt;- readRDS(&quot;generated_data/biomarker_trajectory_pcp.RDS&quot;) biomarker_traj_ukb &lt;- readRDS(&quot;generated_data/biomarker_trajectory_ukb.RDS&quot;) Combine UKB and PCP biomarker trajectory data. biomarker_traj &lt;- bind_rows(biomarker_traj_pcp,biomarker_traj_ukb %&gt;% select(-visit)) biomarker_traj &lt;- biomarker_traj %&gt;% distinct() Load UKB and PCP albuminuria event table. albuminuria_event_tab_pcp &lt;- readRDS(&quot;generated_data/albuminuria_event_tab_pcp.RDS&quot;) albuminuria_event_tab_ukb &lt;- readRDS(&quot;generated_data/albuminuria_event_tab_ukb.RDS&quot;) Combine albuminuria event tables. albuminuria_event_tab &lt;- bind_rows(albuminuria_event_tab_pcp,albuminuria_event_tab_ukb) %&gt;% distinct() Create micro and microalbuminuria first identification event table. microabu_firstoccur &lt;- albuminuria_event_tab %&gt;% filter(type == &quot;microalbuminuria&quot;,event == T) %&gt;% select(f.eid,event,event_dt) %&gt;% group_by(f.eid) %&gt;% arrange(event_dt) %&gt;% slice(1) macroabu_firstoccur &lt;- albuminuria_event_tab %&gt;% filter(type == &quot;macroalbuminuria&quot;,event == T) %&gt;% select(f.eid,event,event_dt) %&gt;% group_by(f.eid) %&gt;% arrange(event_dt) %&gt;% slice(1) Load the demographic table. demog &lt;- readRDS(&quot;generated_data/demog_selected.RDS&quot;) Compute eGFR and create eGFR trajectory data. creat_blood_traj &lt;- biomarker_traj[biomarker_traj$biomarker == &quot;creat_blood&quot;,] %&gt;% left_join(demog %&gt;% select(f.eid, SEX, DOB)) creat_blood_traj$age_egfr &lt;- lubridate::decimal_date(creat_blood_traj$event_dt) - lubridate::decimal_date(creat_blood_traj$DOB) creat_blood_traj$measurement_egfr &lt;- mapply(compute_egfr,creat_blood_traj$measurement,creat_blood_traj$age_egfr,creat_blood_traj$SEX) egfr_traj &lt;- creat_blood_traj %&gt;% select(f.eid,measurement_egfr,event_dt) %&gt;% rename(measurement = measurement_egfr) %&gt;% mutate(biomarker = &quot;egfr&quot;) egfr_traj &lt;- egfr_traj[!is.na(egfr_traj$measurement),] Define a “prolonged low eGFR event” as as an event with two or more low eGFR event (eGFR &lt; 60) for more than 90 days without a normal eGFR in between (which can be ascertained only when we have at least two low eGFR event 90 days apart). low_egfr_firstoccur contains the first occurrence date of the “prolonged low eGFR event.” This event table will be used in phenotyping DKD cases later. prolonged_low_egfr_firstoccur &lt;- egfr_traj %&gt;% mutate(eGFR_lt60 = ifelse(measurement &lt; 60, 1, 0)) %&gt;% group_by(f.eid) %&gt;% arrange(f.eid, event_dt) %&gt;% mutate(switched = eGFR_lt60 != lag(eGFR_lt60)) %&gt;% mutate(run_n = cumsum(ifelse(is.na(switched), 0, switched))) %&gt;% group_by(f.eid, run_n) %&gt;% mutate(max_days = (lubridate::decimal_date(max(event_dt, na.rm=T)) - lubridate::decimal_date(min(event_dt, na.rm=T)))*365.25) %&gt;% filter(eGFR_lt60 &amp; max_days &gt;=90) %&gt;% # for a subject with only one event of egfr &lt; 60, then we would have max_days = 0 ungroup() %&gt;% group_by(f.eid) %&gt;% arrange(event_dt) %&gt;% slice(1) %&gt;% # selecting for the start date of the first period where a subject had egfr level less 60 for # 90+ days. ungroup() %&gt;% select(f.eid, event_dt) Add eGFR trajectory data to biomarker_traj. biomarker_traj &lt;- bind_rows(biomarker_traj,egfr_traj) biomarker_traj &lt;- biomarker_traj[!is.na(biomarker_traj$measurement) &amp; !is.na(biomarker_traj$event_dt),] Break up biomarker trajectory table per biomarker. biomarker_traj_list_per_biomarker &lt;- lapply(unique(biomarker_traj$biomarker),function(biomarker){ biomarker_traj[biomarker_traj$biomarker == biomarker,] }) names(biomarker_traj_list_per_biomarker) &lt;- unique(biomarker_traj$biomarker) Save biomarker trajectory table. saveRDS(biomarker_traj,&quot;generated_data/biomarker_trajectory.RDS&quot;) Save trajectory table for each biomarker. for(i in 1:length(biomarker_traj_list_per_biomarker)){ biomarker &lt;- names(biomarker_traj_list_per_biomarker)[i] saveRDS(biomarker_traj_list_per_biomarker[[i]],paste0(&quot;generated_data/&quot;,&quot;trajectory_&quot;,biomarker,&quot;.RDS&quot;)) } Save albuminuria table. saveRDS(albuminuria_event_tab,&quot;generated_data/albuminuria_event_tab.RDS&quot;) Save macroalbuminuria and microalbuminuria first occurrence table. saveRDS(macroabu_firstoccur,&quot;generated_data/macroabu_firstoccur.RDS&quot;) saveRDS(microabu_firstoccur,&quot;generated_data/microabu_firstoccur.RDS&quot;) Save prolonged low eGFR first occurrence table. saveRDS(prolonged_low_egfr_firstoccur,&quot;generated_data/prolonged_low_egfr_firstoccur.RDS&quot;) "],["13-phenotype-outcome-combine.html", "13 Phenotype outcomes using combination of tables", " 13 Phenotype outcomes using combination of tables In this chapter, we combine event tables generated in the previous chapters to generate diabetes event table and diabetes first occurrence event table diabetic eye disease first occurrence event table diabetic first occurrence event table Load packages. library(tidyverse) library(data.table) source(&quot;functions.R&quot;) DM Load the following datasets: diabetes event table generated using UKB assessment center data (chapter 8) diabetes event table generated using PCP data (chapter 9) dm_pc &lt;- readRDS(&quot;generated_data/dm_pc.RDS&quot;) dm_ukb &lt;- readRDS(&quot;generated_data/dm_ukb.RDS&quot;) Create diabetes event table and diabetes first occurrence event table. The categorize_dm_types() function categorizes events into different diabetes types. The function also resolves any conflict in types of diabetes for each subject with more than one recorded diabetes types. dm &lt;- full_join(dm_ukb %&gt;% select(f.eid, event_dt, dm_type), dm_pc %&gt;% select(f.eid, event_dt, dm_type)) %&gt;% distinct() %&gt;% group_by(f.eid) %&gt;% mutate(dm_type = categorize_dm_types(dm_type)) %&gt;% ungroup() dm_firstoccur &lt;- dm %&gt;% group_by(f.eid) %&gt;% arrange(event_dt) %&gt;% slice(1) %&gt;% ungroup() Import ID’s of subjects represented in the primary care data. gp_subject_ids &lt;- readRDS(&quot;generated_data/gp_subject_ids.RDS&quot;) Show a contingency table of diabetes types and availability of the primary care data for the diabetes cohort. dm_firstoccur %&gt;% mutate(in_gp = f.eid %in% gp_subject_ids) %&gt;% select(dm_type, in_gp) %&gt;% table() %&gt;% addmargins() saveRDS(dm,&quot;generated_data/dm.RDS&quot;) saveRDS(dm_firstoccur,&quot;generated_data/dm_firstoccur.RDS&quot;) DR Load the following datasets: diabetic eye disease first occurrence event table generated using UKB assessment center data (chapter 8) diabetic eye disease event table generated using PCP data (chapter 9) dr_pc &lt;- readRDS(&quot;generated_data/dr_pc.RDS&quot;) dr_firstoccur_ukb &lt;- readRDS(&quot;generated_data/dr_firstoccur_ukb.RDS&quot;) Create diabetic eye disease first occurrence event table. dr_firstoccur &lt;- dr_pc %&gt;% full_join(dr_firstoccur_ukb) %&gt;% group_by(f.eid) %&gt;% arrange(event_dt) %&gt;% slice(1) %&gt;% ungroup() saveRDS(dr_firstoccur,&quot;generated_data/dr_firstoccur.RDS&quot;) DKD Load the following datasets: diabetic kidney disease event table generated using UKB assessment center data (chapter 8) diabetic kidney disease event table generated using PCP data (chapter 9) macroabuminuria first occurrence event table generated using the biomarker trajectory data (chapter 12) prolonged low eGFR first occurrence event table generated using the biomarker trajector data (chapter 12) kidney_disease_case_pc &lt;- readRDS(&quot;generated_data/kidney_disease_case_pc.RDS&quot;) dkd_ukb &lt;- readRDS(&quot;generated_data/dkd_ukb.RDS&quot;) macroabu_firstoccur &lt;- readRDS(&quot;generated_data/macroabu_firstoccur.RDS&quot;) prolonged_low_egfr_firstoccur &lt;- readRDS(&quot;generated_data/prolonged_low_egfr_firstoccur.RDS&quot;) Next, we create the following event tables using low_egfr_firstoccur and macroabu_firstoccur to capture additional DKD cases. prolonged_low_egfr_firstoccur &lt;- prolonged_low_egfr_firstoccur %&gt;% filter(!is.na(event_dt)) macroabu_firstoccur &lt;- macroabu_firstoccur %&gt;% filter(!is.na(event_dt)) %&gt;% select(f.eid,event_dt) Finally, we merge the following event tables to generate first occurrence diabetic kidney disease event table: kidney disease case multiple event table from PCP data diabetic kidney disease multiple event table from UKB assessment center data macroabuminuria first occurrence event table prolonged low eGFR first occurrence event table dkd_firstoccur &lt;- kidney_disease_case_pc %&gt;% full_join(dkd_ukb) %&gt;% full_join(prolonged_low_egfr_firstoccur) %&gt;% full_join(macroabu_firstoccur) %&gt;% filter(!is.na(event_dt)) %&gt;% group_by(f.eid) %&gt;% arrange(event_dt) %&gt;% slice(1) %&gt;% ungroup() saveRDS(dkd_firstoccur,&quot;generated_data/dkd_firstoccur.RDS&quot;) "],["14-tte-macro.html", "14 Generate time-to-event data for macrovascular diabetes complications", " 14 Generate time-to-event data for macrovascular diabetes complications In this chapter, we phenotype right-censored time-to-event data for the following macrovascular diabetes compliations: Myocardial Infarction (MI) Unstable Angina (UA) Ischemic Stroke (IS) Hemorrhagic Stroke (HS) Stroke (ST) PCI Composite CVD To compute time-to-event, we require an index date (time-zero point) and event date of an outcome. In our case, we can define index date to be the first diagnosis date of diabetes or UKB study initiation date. For right-censored data, we define the index date as UKB study initiation date. In later chapters, we create interval-censored data by setting the index date as the first diabetes diagnosis date. We now introduce a phenotyping procedure for right-censored data. For each complication outcome, we create an initial time-to-event data by combining the first occurrence diabetes event table, the first occurrence outcome event table and demographic table. As we merge these data to produce the initial time-to-event data, the cases and controls occur. The case is defined as a subject who has a complication event before the censoring date (defined in chapter 2). Otherwise, a subject is defined as control. Next, we refine the initial time-to-event data by applying the following exclusion criteria for cases and controls: case has a complication event after the censoring date has a prior complication event identified before a first evidence of diabetes has an initiation date that is not between the first evidence of diabetes and the date of complication event control has some event represented in a control exclusion event table(s) (all generated in chapter 8; also see the table below) has a first evidence of diabetes after the censoring date has less than 5 years of follow-up time since the first evidence of diabetes before censoring date has a first evidence of diabets 6 months after the study initiation date The following table shows macrovascular complications and associated control exclusion event table(s): Macrovascular complication Control exclusion outcome Myocardial Infarction cardiovascular control exclusion events Unstable Angina Ischemic Stroke cerebrovascular control exclusion events Hemorrhagic Stroke cerebrovascular control exclusion events Stroke cerebrovascular control exclusion events PCI non-coronary revascularization procedure control exclusion events Composite CVD control exclusion events associated with MI, Ischemic stroke, unstable angina and PCI The event tables for all of the above control exclusion events were created in chapter 8. The phenotyping procedure for time-to-event data is encapsulated in a function phenotype_time_to_event() defined in functions.R. Load packages and functions. library(tidyverse) library(data.table) source(&quot;functions.R&quot;) Load first occurrence DM data. dm_firstoccur &lt;- readRDS(&quot;generated_data/dm_firstoccur.RDS&quot;) Load demographic data. demog &lt;- readRDS(&quot;generated_data/demog_selected.RDS&quot;) MI Load MI first occurrence data phenotyped from UKB assessment data. mi_firstoccur_ukb &lt;- readRDS(&quot;generated_data/mi_firstoccur_ukb.RDS&quot;) %&gt;% select(f.eid,event_dt) Load cardiovascular event table that will be used to exclude controls. cardio &lt;- readRDS(&quot;generated_data/cardio_control_exclusion_events_ukb.RDS&quot;) Define control exclusion subject IDs. ctrl_exclusion_ids_cardio &lt;- cardio$f.eid %&gt;% unique Phenotype time-to-event. mi_tte &lt;- phenotype_time_to_event(dm_firstoccur, mi_firstoccur_ukb, demog, control_exclusion_ids = ctrl_exclusion_ids_cardio) saveRDS(mi_tte,&quot;generated_data/mi_tte.RDS&quot;) Unstable angina Load unstable angina first occurrence data phenotyped from UKB assessment data. unstable_angina_firstoccur_ukb &lt;- readRDS(&quot;generated_data/unstable_angina_firstoccur_ukb.RDS&quot;) %&gt;% select(f.eid,event_dt) Phenotype time-to-event. unstable_angina_tte &lt;- phenotype_time_to_event(dm_firstoccur,unstable_angina_firstoccur_ukb,demog) saveRDS(unstable_angina_tte,&quot;generated_data/unstable_angina_tte.RDS&quot;) Ischemic stroke Load ischemic stroke first occurrence data phenotyped from UKB assessment data. ischemic_stroke_firstoccur_ukb &lt;- readRDS(&quot;generated_data/stroke_infarct_firstoccur_ukb.RDS&quot;) Load cerebrovascular event table that will be used to exclude controls. cerebro &lt;- readRDS(&quot;generated_data/cerebro_control_exclusion_events_ukb.RDS&quot;) Define control exclusion subject IDs. ctrl_exclusion_ids_cerebro &lt;- cerebro$f.eid %&gt;% unique Phenotype time-to-event. ischemic_stroke_tte &lt;- phenotype_time_to_event(dm_firstoccur,ischemic_stroke_firstoccur_ukb,demog, control_exclusion_ids = ctrl_exclusion_ids_cerebro) saveRDS(ischemic_stroke_tte,&quot;generated_data/ischemic_stroke_tte.RDS&quot;) Hemorrhagic Stroke Load hemorrhagic stroke first occurrence data phenotyped from UKB assessment data. hem_stroke_firstoccur_ukb &lt;- readRDS(&quot;generated_data/stroke_hem_firstoccur_ukb.RDS&quot;) Load cerebrovascular event table that will be used to exclude controls. cerebro &lt;- readRDS(&quot;generated_data/cerebro_control_exclusion_events_ukb.RDS&quot;) Define control exclusion subject IDs. ctrl_exclusion_ids_cerebro &lt;- cerebro$f.eid %&gt;% unique Phenotype time-to-event. hem_stroke_tte &lt;- phenotype_time_to_event(dm_firstoccur,hem_stroke_firstoccur_ukb,demog, control_exclusion_ids = ctrl_exclusion_ids_cerebro) saveRDS(hem_stroke_tte,&quot;generated_data/hem_stroke_tte.RDS&quot;) Stroke Load stroke first occurrence data phenotyped from UKB assessment data. stroke_firstoccur_ukb &lt;- readRDS(&quot;generated_data/stroke_firstoccur_ukb.RDS&quot;) Load cerebrovascular event table that will be used to exclude controls. cerebro &lt;- readRDS(&quot;generated_data/cerebro_control_exclusion_events_ukb.RDS&quot;) Define control exclusion subject IDs. ctrl_exclusion_ids_cerebro &lt;- cerebro$f.eid %&gt;% unique Phenotype time-to-event. stroke_tte &lt;- phenotype_time_to_event(dm_firstoccur,stroke_firstoccur_ukb,demog, control_exclusion_ids = ctrl_exclusion_ids_cerebro) saveRDS(stroke_tte,&quot;generated_data/stroke_tte.RDS&quot;) PCI Load PCI first occurrence data phenotyped from UKB assessment data. pci_firstoccur_ukb &lt;- readRDS(&quot;generated_data/pci_firstoccur_ukb.RDS&quot;) Load non-coronary revascularization event table that will be used to exclude controls. other_revas &lt;- readRDS(&quot;generated_data/other_revas_control_exclusion_events_ukb.RDS&quot;) Define control exclusion subject IDs. ctrl_exclusion_ids_other_revas &lt;- other_revas$f.eid %&gt;% unique Phenotype time-to-event. pci_tte &lt;- phenotype_time_to_event(dm_firstoccur,pci_firstoccur_ukb,demog, control_exclusion_ids = ctrl_exclusion_ids_other_revas) saveRDS(pci_tte,&quot;generated_data/pci_tte.RDS&quot;) Composite CVD (MI, Unstable Angina, Ischemic Stroke, PCI or CVD death) Load composite CVD first occurrence data phenotyped from UKB assessment data. cvd_firstoccur_ukb &lt;- readRDS(&quot;generated_data/cvd_firstoccur_ukb.RDS&quot;) Create control exclusion table for CVD. They are combination of cardio, cerebro and other revasculrization events that were used to exclude controls when phenotyping MI, unstable angina, ischemic sstroke and PCI time-to-event data. composite_cvd_control_exclusion_events &lt;- list(cardio,cerebro,other_revas) %&gt;% bind_rows() Define control exclusion subject IDs. ctrl_exclusion_ids_cvd &lt;- composite_cvd_control_exclusion_events$f.eid %&gt;% unique Phenotype time-to-event. cvd_tte &lt;- phenotype_time_to_event(dm_firstoccur,cvd_firstoccur_ukb,demog, control_exclusion_ids = ctrl_exclusion_ids_cvd) saveRDS(cvd_tte,&quot;generated_data/cvd_tte.RDS&quot;) "],["15-tte-dr.html", "15 Generate time-to-event data for diabetic eye disease", " 15 Generate time-to-event data for diabetic eye disease In this chapter, we phenotype right-censored time-to-event data for diabetic eye disease. An initial time-to-event data are created, and consequent cases and controls are identified following the identical procedure described in chapter 14. The initial time-to-event data are refined by applying the following exclusion criteria: case has a complication event after the censoring date has a prior complication event identified before a first evidence of diabetes has an initiation date that is not between the first evidence of diabetes and the date of complication event control has some event represented in diabetic eye disease control exclusion event table (generated in chapter 8) has some event represented in non-diabetic eye disease event table (generated in chapter 9) has a first evidence of diabetes after the censoring date has less than 5 years of follow-up time since the first evidence of diabetes before censoring date has a first evidence of diabetes 6 months after the study initiation date is not represented in the primary care data Load packages and functions. library(tidyverse) library(data.table) source(&quot;functions.R&quot;) Load the following datasets: diabetes first occurrence data selected demographic data first occurrence DR event table dm_firstoccur &lt;- readRDS(&quot;generated_data/dm_firstoccur.RDS&quot;) demog &lt;- readRDS(&quot;generated_data/demog_selected.RDS&quot;) dr_firstoccur &lt;- readRDS(&quot;generated_data/dr_firstoccur.RDS&quot;) Load the following control exclusion event tables: DR control exclusion event table from UKB assessment center data non-diabeetic eye disease control exclusion event table from the primary care data dr_control_exclusion_events_ukb &lt;- readRDS(&quot;generated_data/dr_control_exclusion_events_ukb.RDS&quot;) nondm_eye_disease &lt;- readRDS(&quot;generated_data/nondm_eye_disease_pc.RDS&quot;) Merge control exclusion event tables. dr_control_exclusion_events &lt;- full_join(dr_control_exclusion_events_ukb,nondm_eye_disease,by=c(&quot;f.eid&quot;,&quot;event_dt&quot;)) Define control exclusion subject ID’s. ctrl_exclusion_ids &lt;- dr_control_exclusion_events$f.eid %&gt;% unique The controls should be represented in the primary care data. gp_subejct_ids &lt;- readRDS(&quot;generated_data/gp_subject_ids.RDS&quot;) Define control inclusion subject ID’s. ctrl_inclusion_ids &lt;- gp_subejct_ids %&gt;% unique Phenotype time-to-event table for diabetic eye disease. dr_tte &lt;- phenotype_time_to_event(dm_firstoccur,dr_firstoccur,demog, control_exclusion_ids = ctrl_exclusion_ids, control_inclusion_ids = ctrl_inclusion_ids) saveRDS(dr_tte,&quot;generated_data/dr_tte.RDS&quot;) "],["16-tte-dkd.html", "16 Generate time-to-event data for diabetes related kidney disease", " 16 Generate time-to-event data for diabetes related kidney disease In this chapter, we phenotype right-censored time-to-event data for diabetic kidney disease. An initial time-to-event data are created, and consequent cases and controls are identified following the identical procedure described in chapter 14. The initial time-to-event data are refined by applying the following exclusion criteria: case has a complication event after the censoring date has a prior complication event identified before a first evidence of diabetes has an initiation date that is not between the first evidence of diabetes and the date of complication event has less than 5 years of follow-up time since the first evidence of diabetes before a kidney disease event control has some event represented in diabetic kidney disease control exclusion event table (generated in chapter 8) has some event represented in kidney disease control exclusion event table (generated in chapter 9) has been found to have microalbuminuria at least once does not have eGFR measurements available has been found to have eGFR level less than 60 has a first evidence of diabetes after the censoring date has less than 5 years of follow-up time since the first evidence of diabetes before censoring date has a first evidence of diabetes 6 months after the study initiation date is not represented in the primary care data We identify subjects who have had microalbuminuria at least once using miicroalbuminuria first occurrence event table generated in chapter 12. Subjects with eGFR level less than 60 are identified using eGFR trajectory data created in chapter 12. Load pacakges and functions. library(tidyverse) library(data.table) source(&quot;functions.R&quot;) Load the following datasets: diabetes first occurrence data selected demographic data first occurrence DKD event table eGFR trajectory data microalbuminuria first occurrence event table dm_firstoccur &lt;- readRDS(&quot;generated_data/dm_firstoccur.RDS&quot;) demog &lt;- readRDS(&quot;generated_data/demog_selected.RDS&quot;) dkd_firstoccur &lt;- readRDS(&quot;generated_data/dkd_firstoccur.RDS&quot;) egfr_traj &lt;- readRDS(&quot;generated_data/trajectory_egfr.RDS&quot;) microabu_firstoccur &lt;- readRDS(&quot;generated_data/microabu_firstoccur.RDS&quot;) Load the following control exclusion event tables: DKD control exclusion event table from UKB assessment center data DKD control exclusion event table from PCP data dkd_control_exclusion_events_ukb &lt;- readRDS(&quot;generated_data/dkd_control_exclusion_events_ukb.RDS&quot;) kidney_disease_control_exclusion_events_pc &lt;- readRDS(&quot;generated_data/kidney_disease_control_exclusion_pc.RDS&quot;) Create additional control exclusion event tables: a table containing subjects who have been recorded to have ever had eGFR level less than 60 a table containing subjects who have been recorded to have ever had microalbuminuria egfr_lt60_ever_event_tab &lt;- egfr_traj %&gt;% filter(measurement &lt; 60, !is.na(measurement), !is.na(event_dt)) microabu_ever_event_tab &lt;- microabu_firstoccur %&gt;% filter(!is.na(event)) Merge control exclusion event tables. ckd_control_exclusion_events &lt;- bind_rows(list(dkd_control_exclusion_events_ukb, kidney_disease_control_exclusion_events_pc, egfr_lt60_ever_event_tab,microabu_ever_event_tab)) Define control exclusion subject ID’s. ctrl_exclusion_ids &lt;- ckd_control_exclusion_events$f.eid %&gt;% unique The controls should have linked primary care dataset and at least one eGFR measurement. pcp_subejct_ids &lt;- readRDS(&quot;generated_data/gp_subject_ids.RDS&quot;) eGFR_avail_subject_ids &lt;- (egfr_traj %&gt;% filter(!is.na(measurement) &amp; !is.na(event_dt))) %&gt;% .$f.eid Define control inclusion subject ID’s. ctrl_inclusion_ids &lt;- intersect(pcp_subejct_ids,eGFR_avail_subject_ids) %&gt;% unique dkd_tte &lt;- phenotype_time_to_event(dm_firstoccur,dkd_firstoccur,demog, control_exclusion_ids = ctrl_exclusion_ids, control_inclusion_ids = ctrl_inclusion_ids) We filter out cases that do not have at least 5 years of follow-up time. dkd_tte &lt;- dkd_tte %&gt;% filter(event == 0 | (event == 1 &amp; (lubridate::decimal_date(event_dt_comp) - lubridate::decimal_date(event_dt_dm) &gt;= 5))) saveRDS(dkd_tte,&quot;generated_data/dkd_tte.RDS&quot;) "],["references.html", "References", " References "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
